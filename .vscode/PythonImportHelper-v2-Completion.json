[
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "bittensor",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bittensor",
        "description": "bittensor",
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "axon",
        "importPath": "bittensor",
        "description": "bittensor",
        "isExtraImport": true,
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "dendrite",
        "importPath": "bittensor",
        "description": "bittensor",
        "isExtraImport": true,
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "axon",
        "importPath": "bittensor",
        "description": "bittensor",
        "isExtraImport": true,
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "dendrite",
        "importPath": "bittensor",
        "description": "bittensor",
        "isExtraImport": true,
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "axon",
        "importPath": "bittensor",
        "description": "bittensor",
        "isExtraImport": true,
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "dendrite",
        "importPath": "bittensor",
        "description": "bittensor",
        "isExtraImport": true,
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "print_exception",
        "importPath": "traceback",
        "description": "traceback",
        "isExtraImport": true,
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "BaseNeuron",
        "importPath": "graphite.base.neuron",
        "description": "graphite.base.neuron",
        "isExtraImport": true,
        "detail": "graphite.base.neuron",
        "documentation": {}
    },
    {
        "label": "BaseNeuron",
        "importPath": "graphite.base.neuron",
        "description": "graphite.base.neuron",
        "isExtraImport": true,
        "detail": "graphite.base.neuron",
        "documentation": {}
    },
    {
        "label": "add_miner_args",
        "importPath": "graphite.utils.config",
        "description": "graphite.utils.config",
        "isExtraImport": true,
        "detail": "graphite.utils.config",
        "documentation": {}
    },
    {
        "label": "check_config",
        "importPath": "graphite.utils.config",
        "description": "graphite.utils.config",
        "isExtraImport": true,
        "detail": "graphite.utils.config",
        "documentation": {}
    },
    {
        "label": "add_args",
        "importPath": "graphite.utils.config",
        "description": "graphite.utils.config",
        "isExtraImport": true,
        "detail": "graphite.utils.config",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "graphite.utils.config",
        "description": "graphite.utils.config",
        "isExtraImport": true,
        "detail": "graphite.utils.config",
        "documentation": {}
    },
    {
        "label": "add_validator_args",
        "importPath": "graphite.utils.config",
        "description": "graphite.utils.config",
        "isExtraImport": true,
        "detail": "graphite.utils.config",
        "documentation": {}
    },
    {
        "label": "osmium",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "osmium",
        "description": "osmium",
        "detail": "osmium",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ttl_get_block",
        "importPath": "graphite.utils.misc",
        "description": "graphite.utils.misc",
        "isExtraImport": true,
        "detail": "graphite.utils.misc",
        "documentation": {}
    },
    {
        "label": "graphite",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "graphite",
        "description": "graphite",
        "detail": "graphite",
        "documentation": {}
    },
    {
        "label": "__spec_version__",
        "importPath": "graphite",
        "description": "graphite",
        "isExtraImport": true,
        "detail": "graphite",
        "documentation": {}
    },
    {
        "label": "MockSubtensor",
        "importPath": "graphite.mock",
        "description": "graphite.mock",
        "isExtraImport": true,
        "detail": "graphite.mock",
        "documentation": {}
    },
    {
        "label": "MockMetagraph",
        "importPath": "graphite.mock",
        "description": "graphite.mock",
        "isExtraImport": true,
        "detail": "graphite.mock",
        "documentation": {}
    },
    {
        "label": "MockDendrite",
        "importPath": "graphite.mock",
        "description": "graphite.mock",
        "isExtraImport": true,
        "detail": "graphite.mock",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "download_default_datasets",
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMultiConstrained",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioProblem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "IsAlive",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "MAX_SALESMEN",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMultiConstrained",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioProblem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioProblem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioSynapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMultiConstrained",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMultiConstrained",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMultiConstrained",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioSynapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioProblem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMultiConstrained",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "MAX_SALESMEN",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioProblem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioSynapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioProblem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioSynapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioSynapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "IsAlive",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMultiConstrained",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioProblem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioSynapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "IsAlive",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "isExtraImport": true,
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "geom_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "man_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "euc_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "geom_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "man_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "euc_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "geom_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "euc_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "man_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "geom_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "euc_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "man_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "geom_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "euc_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "man_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "geom_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "euc_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "man_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "geom_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "euc_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "man_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "geom_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "euc_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "man_2d_edges",
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "isExtraImport": true,
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "SubnetPool",
        "importPath": "graphite.base.subnetPool",
        "description": "graphite.base.subnetPool",
        "isExtraImport": true,
        "detail": "graphite.base.subnetPool",
        "documentation": {}
    },
    {
        "label": "SubnetPool",
        "importPath": "graphite.base.subnetPool",
        "description": "graphite.base.subnetPool",
        "isExtraImport": true,
        "detail": "graphite.base.subnetPool",
        "documentation": {}
    },
    {
        "label": "SubnetPool",
        "importPath": "graphite.base.subnetPool",
        "description": "graphite.base.subnetPool",
        "isExtraImport": true,
        "detail": "graphite.base.subnetPool",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "model_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "confloat",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "process_weights_for_netuid",
        "importPath": "graphite.base.utils.weight_utils",
        "description": "graphite.base.utils.weight_utils",
        "isExtraImport": true,
        "detail": "graphite.base.utils.weight_utils",
        "documentation": {}
    },
    {
        "label": "convert_weights_and_uids_for_emit",
        "importPath": "graphite.base.utils.weight_utils",
        "description": "graphite.base.utils.weight_utils",
        "isExtraImport": true,
        "detail": "graphite.base.utils.weight_utils",
        "documentation": {}
    },
    {
        "label": "fetch_rebalancing_axon",
        "importPath": "graphite.utils.yield_utils",
        "description": "graphite.utils.yield_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.yield_utils",
        "documentation": {}
    },
    {
        "label": "fetch_performance_axon",
        "importPath": "graphite.utils.yield_utils",
        "description": "graphite.utils.yield_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.yield_utils",
        "documentation": {}
    },
    {
        "label": "check_uid_availability",
        "importPath": "graphite.utils.uids",
        "description": "graphite.utils.uids",
        "isExtraImport": true,
        "detail": "graphite.utils.uids",
        "documentation": {}
    },
    {
        "label": "get_available_uids",
        "importPath": "graphite.utils.uids",
        "description": "graphite.utils.uids",
        "isExtraImport": true,
        "detail": "graphite.utils.uids",
        "documentation": {}
    },
    {
        "label": "get_available_uids",
        "importPath": "graphite.utils.uids",
        "description": "graphite.utils.uids",
        "isExtraImport": true,
        "detail": "graphite.utils.uids",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "importPath": "requests",
        "description": "requests",
        "isExtraImport": true,
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "getenv",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "environ",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "wandb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wandb",
        "description": "wandb",
        "detail": "wandb",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "BeamSearchSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "HPNSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "DPSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver2",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver4",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "GreedyPortfolioSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "BeamSearchSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "DPSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "HPNSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "DPSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver2",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver4",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "InsertionMultiSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "GreedyPortfolioSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "DPSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "HPNSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "BeamSearchSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "BeamSearchSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "DPSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "HPNSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "graphite.solvers",
        "description": "graphite.solvers",
        "isExtraImport": true,
        "detail": "graphite.solvers",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "asizeof",
        "importPath": "pympler",
        "description": "pympler",
        "isExtraImport": true,
        "detail": "pympler",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "gzip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gzip",
        "description": "gzip",
        "detail": "gzip",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "hf_hub_download",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "ASIA_MSB_DETAILS",
        "importPath": "graphite.data.constants",
        "description": "graphite.data.constants",
        "isExtraImport": true,
        "detail": "graphite.data.constants",
        "documentation": {}
    },
    {
        "label": "WORLD_TSP_DETAILS",
        "importPath": "graphite.data.constants",
        "description": "graphite.data.constants",
        "isExtraImport": true,
        "detail": "graphite.data.constants",
        "documentation": {}
    },
    {
        "label": "USA_POI_DETAILS",
        "importPath": "graphite.data.constants",
        "description": "graphite.data.constants",
        "isExtraImport": true,
        "detail": "graphite.data.constants",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "torch.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "valid_problem",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_portfolio_distribution_similarity",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "normalize_coordinates",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_portfolio_distribution_similarity",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_portfolio_distribution_similarity",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_portfolio_distribution_similarity",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_solution",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_portfolio_distribution_similarity",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_portfolio_distribution_similarity",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_multi_path",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_solution",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_path",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_multi_path",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_solution",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_multi_path",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_solution",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "isExtraImport": true,
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "concurrent.futures",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers.greedy_solver_multi",
        "description": "graphite.solvers.greedy_solver_multi",
        "isExtraImport": true,
        "detail": "graphite.solvers.greedy_solver_multi",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers.greedy_solver_multi",
        "description": "graphite.solvers.greedy_solver_multi",
        "isExtraImport": true,
        "detail": "graphite.solvers.greedy_solver_multi",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers.greedy_solver_multi",
        "description": "graphite.solvers.greedy_solver_multi",
        "isExtraImport": true,
        "detail": "graphite.solvers.greedy_solver_multi",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers.greedy_solver_multi",
        "description": "graphite.solvers.greedy_solver_multi",
        "isExtraImport": true,
        "detail": "graphite.solvers.greedy_solver_multi",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "importPath": "graphite.solvers.greedy_solver_multi",
        "description": "graphite.solvers.greedy_solver_multi",
        "isExtraImport": true,
        "detail": "graphite.solvers.greedy_solver_multi",
        "documentation": {}
    },
    {
        "label": "HPN",
        "importPath": "graphite.models.hybrid_pointer_network",
        "description": "graphite.models.hybrid_pointer_network",
        "isExtraImport": true,
        "detail": "graphite.models.hybrid_pointer_network",
        "documentation": {}
    },
    {
        "label": "distance",
        "importPath": "scipy.spatial",
        "description": "scipy.spatial",
        "isExtraImport": true,
        "detail": "scipy.spatial",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver2",
        "importPath": "graphite.solvers.greedy_solver_multi_2",
        "description": "graphite.solvers.greedy_solver_multi_2",
        "isExtraImport": true,
        "detail": "graphite.solvers.greedy_solver_multi_2",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "update_wrapper",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "RotatingFileHandler",
        "importPath": "logging.handlers",
        "description": "logging.handlers",
        "isExtraImport": true,
        "detail": "logging.handlers",
        "documentation": {}
    },
    {
        "label": "get_rewards",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScoreResponse",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScorePortfolioResponse",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "get_portfolio_rewards",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScorePortfolioResponse",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "get_portfolio_rewards",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScoreYieldResponse",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScoreResponse",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "scaled_rewards",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScoreResponse",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScoreResponse",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScoreResponse",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScoreResponse",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScoreResponse",
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "isExtraImport": true,
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "ScoreType",
        "importPath": "graphite.base.validator",
        "description": "graphite.base.validator",
        "isExtraImport": true,
        "detail": "graphite.base.validator",
        "documentation": {}
    },
    {
        "label": "ScoreType",
        "importPath": "graphite.base.validator",
        "description": "graphite.base.validator",
        "isExtraImport": true,
        "detail": "graphite.base.validator",
        "documentation": {}
    },
    {
        "label": "BaseValidatorNeuron",
        "importPath": "graphite.base.validator",
        "description": "graphite.base.validator",
        "isExtraImport": true,
        "detail": "graphite.base.validator",
        "documentation": {}
    },
    {
        "label": "ScoreType",
        "importPath": "graphite.base.validator",
        "description": "graphite.base.validator",
        "isExtraImport": true,
        "detail": "graphite.base.validator",
        "documentation": {}
    },
    {
        "label": "BaseValidatorNeuron",
        "importPath": "graphite.base.validator",
        "description": "graphite.base.validator",
        "isExtraImport": true,
        "detail": "graphite.base.validator",
        "documentation": {}
    },
    {
        "label": "BaseValidatorNeuron",
        "importPath": "graphite.base.validator",
        "description": "graphite.base.validator",
        "isExtraImport": true,
        "detail": "graphite.base.validator",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver4",
        "importPath": "graphite.solvers.greedy_solver_multi_4",
        "description": "graphite.solvers.greedy_solver_multi_4",
        "isExtraImport": true,
        "detail": "graphite.solvers.greedy_solver_multi_4",
        "documentation": {}
    },
    {
        "label": "GreedyPortfolioSolver",
        "importPath": "graphite.solvers.greedy_portfolio_solver",
        "description": "graphite.solvers.greedy_portfolio_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.greedy_portfolio_solver",
        "documentation": {}
    },
    {
        "label": "GreedyPortfolioSolver",
        "importPath": "graphite.solvers.greedy_portfolio_solver",
        "description": "graphite.solvers.greedy_portfolio_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.greedy_portfolio_solver",
        "documentation": {}
    },
    {
        "label": "OrganicPortfolioRequestSynapse",
        "importPath": "graphite.organic_protocol",
        "description": "graphite.organic_protocol",
        "isExtraImport": true,
        "detail": "graphite.organic_protocol",
        "documentation": {}
    },
    {
        "label": "OrganicPortfolioResponseSynapse",
        "importPath": "graphite.organic_protocol",
        "description": "graphite.organic_protocol",
        "isExtraImport": true,
        "detail": "graphite.organic_protocol",
        "documentation": {}
    },
    {
        "label": "BENCHMARK_SOLUTIONS",
        "importPath": "graphite.utils.constants",
        "description": "graphite.utils.constants",
        "isExtraImport": true,
        "detail": "graphite.utils.constants",
        "documentation": {}
    },
    {
        "label": "COST_FUNCTIONS",
        "importPath": "graphite.utils.constants",
        "description": "graphite.utils.constants",
        "isExtraImport": true,
        "detail": "graphite.utils.constants",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolverVali",
        "importPath": "graphite.solvers.greedy_solver_vali",
        "description": "graphite.solvers.greedy_solver_vali",
        "isExtraImport": true,
        "detail": "graphite.solvers.greedy_solver_vali",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolverVali",
        "importPath": "graphite.solvers.greedy_solver_vali",
        "description": "graphite.solvers.greedy_solver_vali",
        "isExtraImport": true,
        "detail": "graphite.solvers.greedy_solver_vali",
        "documentation": {}
    },
    {
        "label": "YieldDataRequestSynapse",
        "importPath": "graphite.yield_protocol",
        "description": "graphite.yield_protocol",
        "isExtraImport": true,
        "detail": "graphite.yield_protocol",
        "documentation": {}
    },
    {
        "label": "MinerYield",
        "importPath": "graphite.yield_protocol",
        "description": "graphite.yield_protocol",
        "isExtraImport": true,
        "detail": "graphite.yield_protocol",
        "documentation": {}
    },
    {
        "label": "LeaderPerformanceData",
        "importPath": "graphite.yield_protocol",
        "description": "graphite.yield_protocol",
        "isExtraImport": true,
        "detail": "graphite.yield_protocol",
        "documentation": {}
    },
    {
        "label": "YieldDataRequestSynapse",
        "importPath": "graphite.yield_protocol",
        "description": "graphite.yield_protocol",
        "isExtraImport": true,
        "detail": "graphite.yield_protocol",
        "documentation": {}
    },
    {
        "label": "MinerYield",
        "importPath": "graphite.yield_protocol",
        "description": "graphite.yield_protocol",
        "isExtraImport": true,
        "detail": "graphite.yield_protocol",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "is_valid_ss58_address",
        "importPath": "bittensor.utils",
        "description": "bittensor.utils",
        "isExtraImport": true,
        "detail": "bittensor.utils",
        "documentation": {}
    },
    {
        "label": "BaseMinerNeuron",
        "importPath": "graphite.base.miner",
        "description": "graphite.base.miner",
        "isExtraImport": true,
        "detail": "graphite.base.miner",
        "documentation": {}
    },
    {
        "label": "forward",
        "importPath": "graphite.validator",
        "description": "graphite.validator",
        "isExtraImport": true,
        "detail": "graphite.validator",
        "documentation": {}
    },
    {
        "label": "organic_forward",
        "importPath": "graphite.validator",
        "description": "graphite.validator",
        "isExtraImport": true,
        "detail": "graphite.validator",
        "documentation": {}
    },
    {
        "label": "yield_forward",
        "importPath": "graphite.validator",
        "description": "graphite.validator",
        "isExtraImport": true,
        "detail": "graphite.validator",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "MetricMTSPV2Generator",
        "importPath": "graphite.data.dataset_generator_v2",
        "description": "graphite.data.dataset_generator_v2",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_generator_v2",
        "documentation": {}
    },
    {
        "label": "MetricMTSPV2Generator",
        "importPath": "graphite.data.dataset_generator_v2",
        "description": "graphite.data.dataset_generator_v2",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_generator_v2",
        "documentation": {}
    },
    {
        "label": "MetricMTSPV2Generator",
        "importPath": "graphite.data.dataset_generator_v2",
        "description": "graphite.data.dataset_generator_v2",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_generator_v2",
        "documentation": {}
    },
    {
        "label": "MetricMTSPV2Generator",
        "importPath": "graphite.data.dataset_generator_v2",
        "description": "graphite.data.dataset_generator_v2",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_generator_v2",
        "documentation": {}
    },
    {
        "label": "MetricTSPV2Generator",
        "importPath": "graphite.data.dataset_generator_v2",
        "description": "graphite.data.dataset_generator_v2",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_generator_v2",
        "documentation": {}
    },
    {
        "label": "MetricMTSPV2Generator",
        "importPath": "graphite.data.dataset_generator_v2",
        "description": "graphite.data.dataset_generator_v2",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_generator_v2",
        "documentation": {}
    },
    {
        "label": "cycle",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "islice",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "cycle",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "islice",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "cycle",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "islice",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "NaiveSolver",
        "importPath": "graphite.solvers.naive_v2_solver",
        "description": "graphite.solvers.naive_v2_solver",
        "isExtraImport": true,
        "detail": "graphite.solvers.naive_v2_solver",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tqdm",
        "description": "tqdm",
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "MetricTSPGenerator",
        "importPath": "graphite.data.dataset_generator",
        "description": "graphite.data.dataset_generator",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_generator",
        "documentation": {}
    },
    {
        "label": "GeneralTSPGenerator",
        "importPath": "graphite.data.dataset_generator",
        "description": "graphite.data.dataset_generator",
        "isExtraImport": true,
        "detail": "graphite.data.dataset_generator",
        "documentation": {}
    },
    {
        "label": "Keypair",
        "importPath": "substrateinterface",
        "description": "substrateinterface",
        "isExtraImport": true,
        "detail": "substrateinterface",
        "documentation": {}
    },
    {
        "label": "Keypair",
        "importPath": "substrateinterface",
        "description": "substrateinterface",
        "isExtraImport": true,
        "detail": "substrateinterface",
        "documentation": {}
    },
    {
        "label": "unhexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "parse_requirements",
        "importPath": "pkg_resources",
        "description": "pkg_resources",
        "isExtraImport": true,
        "detail": "pkg_resources",
        "documentation": {}
    },
    {
        "label": "normalize_max_weight",
        "kind": 2,
        "importPath": "graphite.base.utils.weight_utils",
        "description": "graphite.base.utils.weight_utils",
        "peekOfCode": "def normalize_max_weight(\n    x: np.ndarray, limit: float = 0.1\n) -> np.ndarray:\n    r\"\"\"Normalizes the numpy array x so that sum(x) = 1 and the max value is not greater than the limit.\n    Args:\n        x (:obj:`np.ndarray`):\n            Array to be max_value normalized.\n        limit: float:\n            Max value after normalization.\n    Returns:",
        "detail": "graphite.base.utils.weight_utils",
        "documentation": {}
    },
    {
        "label": "convert_weights_and_uids_for_emit",
        "kind": 2,
        "importPath": "graphite.base.utils.weight_utils",
        "description": "graphite.base.utils.weight_utils",
        "peekOfCode": "def convert_weights_and_uids_for_emit(\n    uids: np.ndarray, weights: np.ndarray\n) -> Tuple[List[int], List[int]]:\n    r\"\"\"Converts weights into integer u32 representation that sum to MAX_INT_WEIGHT.\n    Args:\n        uids (:obj:`np.ndarray,`):\n            Array of uids as destinations for passed weights.\n        weights (:obj:`np.ndarray,`):\n            Array of weights.\n    Returns:",
        "detail": "graphite.base.utils.weight_utils",
        "documentation": {}
    },
    {
        "label": "process_weights_for_netuid",
        "kind": 2,
        "importPath": "graphite.base.utils.weight_utils",
        "description": "graphite.base.utils.weight_utils",
        "peekOfCode": "def process_weights_for_netuid(\n    uids,\n    weights: np.ndarray,\n    netuid: int,\n    subtensor: \"bittensor.subtensor\",\n    metagraph: \"bittensor.metagraph\" = None,\n    exclude_quantile: int = 0,\n) -> np.ndarray:\n    bittensor.logging.debug(\"process_weights_for_netuid()\")\n    bittensor.logging.debug(\"weights\", weights)",
        "detail": "graphite.base.utils.weight_utils",
        "documentation": {}
    },
    {
        "label": "U32_MAX",
        "kind": 5,
        "importPath": "graphite.base.utils.weight_utils",
        "description": "graphite.base.utils.weight_utils",
        "peekOfCode": "U32_MAX = 4294967295\nU16_MAX = 65535\ndef normalize_max_weight(\n    x: np.ndarray, limit: float = 0.1\n) -> np.ndarray:\n    r\"\"\"Normalizes the numpy array x so that sum(x) = 1 and the max value is not greater than the limit.\n    Args:\n        x (:obj:`np.ndarray`):\n            Array to be max_value normalized.\n        limit: float:",
        "detail": "graphite.base.utils.weight_utils",
        "documentation": {}
    },
    {
        "label": "U16_MAX",
        "kind": 5,
        "importPath": "graphite.base.utils.weight_utils",
        "description": "graphite.base.utils.weight_utils",
        "peekOfCode": "U16_MAX = 65535\ndef normalize_max_weight(\n    x: np.ndarray, limit: float = 0.1\n) -> np.ndarray:\n    r\"\"\"Normalizes the numpy array x so that sum(x) = 1 and the max value is not greater than the limit.\n    Args:\n        x (:obj:`np.ndarray`):\n            Array to be max_value normalized.\n        limit: float:\n            Max value after normalization.",
        "detail": "graphite.base.utils.weight_utils",
        "documentation": {}
    },
    {
        "label": "BaseMinerNeuron",
        "kind": 6,
        "importPath": "graphite.base.miner",
        "description": "graphite.base.miner",
        "peekOfCode": "class BaseMinerNeuron(BaseNeuron):\n    \"\"\"\n    Base class for Bittensor miners.\n    \"\"\"\n    neuron_type: str = \"MinerNeuron\"\n    @classmethod\n    def add_args(cls, parser: argparse.ArgumentParser):\n        super().add_args(parser)\n        add_miner_args(cls, parser)\n    def __init__(self, config=None):",
        "detail": "graphite.base.miner",
        "documentation": {}
    },
    {
        "label": "BaseNeuron",
        "kind": 6,
        "importPath": "graphite.base.neuron",
        "description": "graphite.base.neuron",
        "peekOfCode": "class BaseNeuron(ABC):\n    \"\"\"\n    Base class for Bittensor miners. This class is abstract and should be inherited by a subclass. It contains the core logic for all neurons; validators and miners.\n    In addition to creating a wallet, subtensor, and metagraph, this class also handles the synchronization of the network state via a basic checkpointing mechanism based on epoch length.\n    \"\"\"\n    neuron_type: str = \"BaseNeuron\"\n    @classmethod\n    def check_config(cls, config: \"bt.Config\"):\n        check_config(cls, config)\n    @classmethod",
        "detail": "graphite.base.neuron",
        "documentation": {}
    },
    {
        "label": "SubnetPool",
        "kind": 6,
        "importPath": "graphite.base.subnetPool",
        "description": "graphite.base.subnetPool",
        "peekOfCode": "class SubnetPool():\n    def __init__(self, num_tao_tokens, num_alpha_tokens, netuid):\n        self.num_tao_tokens = num_tao_tokens\n        self.num_alpha_tokens = num_alpha_tokens\n        self.netuid = netuid\n    # if the origin address is root pool or if the origin netuid is the same as the destination then charge the same\n    def swap_alpha_to_tao(self, input_alpha_tokens):\n        if self.netuid == 0:\n            fee = 50000\n            self.num_tao_tokens -= (input_alpha_tokens - fee)",
        "detail": "graphite.base.subnetPool",
        "documentation": {}
    },
    {
        "label": "ScoreType",
        "kind": 6,
        "importPath": "graphite.base.validator",
        "description": "graphite.base.validator",
        "peekOfCode": "class ScoreType(Enum):\n    ORGANIC = \"organic\"\n    SYNTHETIC = \"synthetic\"\n    YIELD = \"yield\"\nclass CompositeScore(BaseModel):\n    organic_score: np.ndarray = Field(default_factory=list)\n    synthetic_score: np.ndarray = Field(default_factory=list)\n    yield_score: np.ndarray = Field(default_factory=list)\n    model_config = ConfigDict(\n        from_attributes=True,",
        "detail": "graphite.base.validator",
        "documentation": {}
    },
    {
        "label": "CompositeScore",
        "kind": 6,
        "importPath": "graphite.base.validator",
        "description": "graphite.base.validator",
        "peekOfCode": "class CompositeScore(BaseModel):\n    organic_score: np.ndarray = Field(default_factory=list)\n    synthetic_score: np.ndarray = Field(default_factory=list)\n    yield_score: np.ndarray = Field(default_factory=list)\n    model_config = ConfigDict(\n        from_attributes=True,\n        arbitrary_types_allowed=True\n        )\n    @property\n    def composite_score(self):",
        "detail": "graphite.base.validator",
        "documentation": {}
    },
    {
        "label": "BaseValidatorNeuron",
        "kind": 6,
        "importPath": "graphite.base.validator",
        "description": "graphite.base.validator",
        "peekOfCode": "class BaseValidatorNeuron(BaseNeuron):\n    \"\"\"\n    Base class for Bittensor validators. Your validator should inherit from this class.\n    \"\"\"\n    neuron_type: str = \"ValidatorNeuron\"\n    @classmethod\n    def add_args(cls, parser: argparse.ArgumentParser):\n        super().add_args(parser)\n        add_validator_args(cls, parser)\n    @abstractmethod",
        "detail": "graphite.base.validator",
        "documentation": {}
    },
    {
        "label": "ASIA_MSB_DETAILS",
        "kind": 5,
        "importPath": "graphite.data.constants",
        "description": "graphite.data.constants",
        "peekOfCode": "ASIA_MSB_DETAILS = {\"endpoint\":\"https://download.geofabrik.de/asia/malaysia-singapore-brunei-240905.osm.pbf\", \n                    \"ref_id\":\"Asia_MSB\"}\nWORLD_TSP_DETAILS = {\"endpoint\":\"https://www.math.uwaterloo.ca/tsp/world/world.tsp.gz\",\n                     \"ref_id\":\"World_TSP\"}\nUSA_POI_DETAILS = {\"endpoint\":None,\n                   \"ref_id\":\"USA_POI\",\n                   \"checksum\":\"b76546c0b9591c5df01a4b235e7c1377\"}",
        "detail": "graphite.data.constants",
        "documentation": {}
    },
    {
        "label": "WORLD_TSP_DETAILS",
        "kind": 5,
        "importPath": "graphite.data.constants",
        "description": "graphite.data.constants",
        "peekOfCode": "WORLD_TSP_DETAILS = {\"endpoint\":\"https://www.math.uwaterloo.ca/tsp/world/world.tsp.gz\",\n                     \"ref_id\":\"World_TSP\"}\nUSA_POI_DETAILS = {\"endpoint\":None,\n                   \"ref_id\":\"USA_POI\",\n                   \"checksum\":\"b76546c0b9591c5df01a4b235e7c1377\"}",
        "detail": "graphite.data.constants",
        "documentation": {}
    },
    {
        "label": "USA_POI_DETAILS",
        "kind": 5,
        "importPath": "graphite.data.constants",
        "description": "graphite.data.constants",
        "peekOfCode": "USA_POI_DETAILS = {\"endpoint\":None,\n                   \"ref_id\":\"USA_POI\",\n                   \"checksum\":\"b76546c0b9591c5df01a4b235e7c1377\"}",
        "detail": "graphite.data.constants",
        "documentation": {}
    },
    {
        "label": "DatasetGenerator",
        "kind": 6,
        "importPath": "graphite.data.dataset_generator",
        "description": "graphite.data.dataset_generator",
        "peekOfCode": "class DatasetGenerator(ABC):\n    @classmethod\n    @abstractmethod\n    def generate_n_samples(cls, n:int, problem_model:GraphV1Problem, **kwargs)->List[GraphV1Problem]:\n        '''\n        Returns a list of dictionaries containing the parameters required to initialize each problem\n        This can be used in-situ to generate a dataset without saving it\n        '''\n        ...\n    @classmethod",
        "detail": "graphite.data.dataset_generator",
        "documentation": {}
    },
    {
        "label": "MetricTSPGenerator",
        "kind": 6,
        "importPath": "graphite.data.dataset_generator",
        "description": "graphite.data.dataset_generator",
        "peekOfCode": "class MetricTSPGenerator(DatasetGenerator):\n    save_dir = os.path.join(DATASET_DIR,'metric_tsp')\n    file_name = os.path.join('dataset.json')\n    problem_weights = [0.1, 0.4, 0.4, 0.1] # probability of choosing a small, medium, large, or very large problem\n    @classmethod\n    def generate_n_samples(cls, n: int):\n        # generate 15 cities as a default with random coordinates\n        problems = []\n        sizes = []\n        for _ in range(n):",
        "detail": "graphite.data.dataset_generator",
        "documentation": {}
    },
    {
        "label": "GeneralTSPGenerator",
        "kind": 6,
        "importPath": "graphite.data.dataset_generator",
        "description": "graphite.data.dataset_generator",
        "peekOfCode": "class GeneralTSPGenerator(DatasetGenerator):\n    save_dir = os.path.join(DATASET_DIR,'general_tsp')\n    file_name = os.path.join('dataset.json')\n    problem_weights = [0.1, 0.4, 0.4, 0.1] # probability of choosing a small, medium, large, or very large problem\n    @classmethod\n    def generate_n_samples(cls, n: int):\n        # generate 15 cities as a default with random coordinates\n        problems = []\n        sizes = []\n        for _ in range(n):",
        "detail": "graphite.data.dataset_generator",
        "documentation": {}
    },
    {
        "label": "print_value_count",
        "kind": 2,
        "importPath": "graphite.data.dataset_generator",
        "description": "graphite.data.dataset_generator",
        "peekOfCode": "def print_value_count(strings):\n    # Use Counter to count the occurrences of each string in the list\n    counter = Counter(strings)\n    # Print the counts\n    for value, count in counter.items():\n        print(f\"{value}: {count}\")\nclass DatasetGenerator(ABC):\n    @classmethod\n    @abstractmethod\n    def generate_n_samples(cls, n:int, problem_model:GraphV1Problem, **kwargs)->List[GraphV1Problem]:",
        "detail": "graphite.data.dataset_generator",
        "documentation": {}
    },
    {
        "label": "DATASET_DIR",
        "kind": 5,
        "importPath": "graphite.data.dataset_generator",
        "description": "graphite.data.dataset_generator",
        "peekOfCode": "DATASET_DIR = Path(__file__).resolve().parent.parent.parent.joinpath(\"dataset\")\ndef print_value_count(strings):\n    # Use Counter to count the occurrences of each string in the list\n    counter = Counter(strings)\n    # Print the counts\n    for value, count in counter.items():\n        print(f\"{value}: {count}\")\nclass DatasetGenerator(ABC):\n    @classmethod\n    @abstractmethod",
        "detail": "graphite.data.dataset_generator",
        "documentation": {}
    },
    {
        "label": "DatasetGenerator",
        "kind": 6,
        "importPath": "graphite.data.dataset_generator_v2",
        "description": "graphite.data.dataset_generator_v2",
        "peekOfCode": "class DatasetGenerator(ABC):\n    @classmethod\n    @abstractmethod\n    def generate_n_samples(cls, n:int, problem_model:GraphV2Problem, loaded_datasets, **kwargs)->List[GraphV2Problem]:\n        '''\n        Returns a list of dictionaries containing the parameters required to initialize each problem\n        This can be used in-situ to generate a dataset without saving it\n        '''\n        ...\n    @classmethod",
        "detail": "graphite.data.dataset_generator_v2",
        "documentation": {}
    },
    {
        "label": "MetricTSPV2Generator",
        "kind": 6,
        "importPath": "graphite.data.dataset_generator_v2",
        "description": "graphite.data.dataset_generator_v2",
        "peekOfCode": "class MetricTSPV2Generator(DatasetGenerator):\n    save_dir = os.path.join(DATASET_DIR,'metric_tsp_v2')\n    file_name = os.path.join('dataset.json')\n    @classmethod\n    def _problem_size(self, problem: GraphV2Problem):\n        return problem.n_nodes // 1000 * 1000 # round problem size to the nearest 1000 (just for categorical assignment)\n    @classmethod\n    def recreate_edges(cls, problem: GraphV2Problem, loaded_datasets):\n        node_coords_np = loaded_datasets[problem.dataset_ref][\"data\"]\n        node_coords = np.array([node_coords_np[i][1:] for i in problem.selected_ids])",
        "detail": "graphite.data.dataset_generator_v2",
        "documentation": {}
    },
    {
        "label": "MetricMTSPV2Generator",
        "kind": 6,
        "importPath": "graphite.data.dataset_generator_v2",
        "description": "graphite.data.dataset_generator_v2",
        "peekOfCode": "class MetricMTSPV2Generator(DatasetGenerator):\n    save_dir = os.path.join(DATASET_DIR,'mtsp_v2')\n    file_name = os.path.join('dataset.json')\n    @classmethod\n    def _problem_size(self, problem: GraphV2ProblemMulti):\n        return problem.n_nodes // 500 * 500 # round down problem size to the nearest 500\n    @classmethod\n    def recreate_edges(cls, problem: GraphV2ProblemMulti, loaded_datasets):\n        node_coords_np = loaded_datasets[problem.dataset_ref][\"data\"]\n        node_coords = np.array([node_coords_np[i][1:] for i in problem.selected_ids])",
        "detail": "graphite.data.dataset_generator_v2",
        "documentation": {}
    },
    {
        "label": "DATASET_DIR",
        "kind": 5,
        "importPath": "graphite.data.dataset_generator_v2",
        "description": "graphite.data.dataset_generator_v2",
        "peekOfCode": "DATASET_DIR = Path(__file__).resolve().parent.parent.parent.joinpath(\"dataset\")\nclass DatasetGenerator(ABC):\n    @classmethod\n    @abstractmethod\n    def generate_n_samples(cls, n:int, problem_model:GraphV2Problem, loaded_datasets, **kwargs)->List[GraphV2Problem]:\n        '''\n        Returns a list of dictionaries containing the parameters required to initialize each problem\n        This can be used in-situ to generate a dataset without saving it\n        '''\n        ...",
        "detail": "graphite.data.dataset_generator_v2",
        "documentation": {}
    },
    {
        "label": "create_directory_if_not_exists",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def create_directory_if_not_exists(directory_path: str) -> None:\n    if not os.path.exists(directory_path):\n        os.makedirs(directory_path, exist_ok=True)\n        print(f\"Directory created: {directory_path}\")\n    else:\n        print(f\"Directory already exists: {directory_path}\")\n#_________________________________________#\n###### Helper functions for training ######\n#_________________________________________#\ndef get_file_path(ref_id:str)->Path:",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "get_file_path",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def get_file_path(ref_id:str)->Path:\n    '''\n    Inputs: ref_id unique identifier of supported dataset\n    returns the file paths of the zipped coordinates\n    '''\n    file_with_extension = ref_id + \".npz\"\n    return DATASET_DIR / file_with_extension\ndef get_checksum(coordinates:np.array)->str:\n    '''\n    Function getting 128 byte checksum for aligning datasets between validator and miner.",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "get_checksum",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def get_checksum(coordinates:np.array)->str:\n    '''\n    Function getting 128 byte checksum for aligning datasets between validator and miner.\n    Inputs: coordinates numpy array representing node coordinates of the dataset\n    Output: md5 hash\n    '''\n    hash_algo='md5'\n    hash_func=getattr(hashlib, hash_algo)()\n    hash_func.update(coordinates.tobytes())\n    return hash_func.hexdigest()",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_dataset",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def load_dataset(ref_id:str)->dict:\n    '''\n    loads in coordinate information from the referenced .npz file and returns the coordinates\n    Inputs: ref_id name of dataset\n    '''\n    filepath = get_file_path(ref_id)\n    try:\n        array_map = np.load(filepath)\n        return {\"data\":array_map['data'],\"checksum\": get_checksum(array_map['data'])}\n    except OSError as e:",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "check_data_match",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def check_data_match(coordinates:np.array, checksum:str):\n    '''\n    Function called on the incoming synapse if both the validator and the miner support data checking.\n    Inputs: coordinates numpy array loaded from .npz file\n            checksum hash computed by the validator based on its reference data\n    '''\n    hash_algo='md5'\n    hash_func=getattr(hashlib, hash_algo)()\n    hash_func.update(coordinates.tobytes())\n    return hash_func.hexdigest() == checksum",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "check_and_get_msb",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def check_and_get_msb():\n    fp = get_file_path(ASIA_MSB_DETAILS['ref_id'])\n    if fp.exists():\n        # we have already downloaded and processed the data\n        bt.logging.info(f\"{ASIA_MSB_DETAILS['ref_id']} already downloaded\")\n        return\n    else:\n        try:\n            create_directory_if_not_exists(DATASET_DIR)\n            bt.logging.info(f\"Downloading {ASIA_MSB_DETAILS['ref_id']} data from huggingface\")",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "check_and_get_wtsp",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def check_and_get_wtsp():\n    fp = get_file_path(WORLD_TSP_DETAILS['ref_id'])\n    if fp.exists():\n        # we have already downloaded and processed the data\n        bt.logging.info(f\"{WORLD_TSP_DETAILS['ref_id']} already downloaded\")\n        return\n    else:\n        try:\n            create_directory_if_not_exists(DATASET_DIR)\n            bt.logging.info(f\"Downloading {WORLD_TSP_DETAILS['ref_id']} data from huggingface\")",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "check_and_get_usa_poi",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def check_and_get_usa_poi():\n    fp = get_file_path(USA_POI_DETAILS['ref_id'])\n    if fp.exists():\n        # we have already downloaded and processed the data\n        # attempt to load and check against the checksum\n        usa_dataset = np.load(fp)\n        usa_dataset_checksum = usa_dataset['checksum']\n        if usa_dataset_checksum != USA_POI_DETAILS['checksum']:\n            bt.logging.info(f\"Downloading {USA_POI_DETAILS['ref_id']} data from huggingface\")\n            hf_hub_download(repo_id=\"Graphite-AI/coordinate_data\", filename=\"USA_POI.npz\", repo_type=\"dataset\", local_dir=DATASET_DIR)",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "download_default_datasets",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def download_default_datasets():\n    check_and_get_msb()\n    check_and_get_wtsp()\n    check_and_get_usa_poi()\ndef load_default_dataset(neuron):\n    '''\n    Loads the default dataset into neuron as a dict of {\"dataset_name\":{\"coordinates\":np.array, \"checksum\":str}}\n    '''\n    create_directory_if_not_exists(DATASET_DIR)\n    # check and process default datasets",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "load_default_dataset",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def load_default_dataset(neuron):\n    '''\n    Loads the default dataset into neuron as a dict of {\"dataset_name\":{\"coordinates\":np.array, \"checksum\":str}}\n    '''\n    create_directory_if_not_exists(DATASET_DIR)\n    # check and process default datasets\n    download_default_datasets()\n    # set the neuron dataset attribute\n    neuron.loaded_datasets = {\n        ASIA_MSB_DETAILS['ref_id']: load_dataset(ASIA_MSB_DETAILS['ref_id']),",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "random_sample_batch",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def random_sample_batch(coordinates: torch.Tensor, num_batches: int, batch_size: int) -> torch.Tensor:\n    # selects n coordinates from the pool of all possible coordinates\n    if not isinstance(coordinates, torch.Tensor):\n        coordinates = torch.Tensor(coordinates, dtype=torch.float32)\n    num_coords = coordinates.size(0), \"Trying to sample more nodes than available in the dataset\"\n    if batch_size > num_coords:\n        raise ValueError(\"Attempting to sample more nodes that available in the dataset\")\n    sampled_indices = torch.randint(0, num_coords, (num_batches, num_coords), dtype=torch.long).cuda()\n    sampled_coords = torch.stack([coordinates[idx] for idx in sampled_indices])\n    return sampled_coords",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "haversine_distance",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def haversine_distance(coord1, coord2):\n    \"\"\"\n    Compute the Haversine distance between two coordinates per this TSP standard (note that our native code does not only support this mode of geom distance compute)\n    :param coord1: A 1D tensor with two elements (latitude, longitude) for the first coordinate.\n    :param coord2: A 1D tensor with two elements (latitude, longitude) for the second coordinate.\n    :return: The Haversine distance in kilometers.\n    \"\"\"\n    # Radius of Earth in kilometers\n    R = 6371.0\n    lat1, lon1 = coord1",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "geom_tour_length",
        "kind": 2,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "def geom_tour_length(x, tour):\n    \"\"\"\n    Compute the length of a batch of tours\n    Inputs : x of size (bsz, nb_nodes, 2) batch of tsp tour instances\n             tour of size (bsz, nb_nodes) batch of sequences (node indices) of tsp tours\n    Output : distance of size (bsz,)             batch of distances of each tsp tour\n    \"\"\"\n    bsz = x.shape[0]\n    nb_nodes = x.shape[1]\n    arange_vec = torch.arange(bsz, device=x.device)",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "DATASET_DIR",
        "kind": 5,
        "importPath": "graphite.data.dataset_utils",
        "description": "graphite.data.dataset_utils",
        "peekOfCode": "DATASET_DIR = Path(__file__).resolve().parent.parent.parent.joinpath(\"dataset\")\n# checks if directory exists and creates it if it doesn't\ndef create_directory_if_not_exists(directory_path: str) -> None:\n    if not os.path.exists(directory_path):\n        os.makedirs(directory_path, exist_ok=True)\n        print(f\"Directory created: {directory_path}\")\n    else:\n        print(f\"Directory already exists: {directory_path}\")\n#_________________________________________#\n###### Helper functions for training ######",
        "detail": "graphite.data.dataset_utils",
        "documentation": {}
    },
    {
        "label": "euc_2d",
        "kind": 2,
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "peekOfCode": "def euc_2d(head:Iterable[Union[int,float]], tail:Iterable[Union[int,float]]):\n    '''\n    Computes the 2d euclidean distance of head vs tail\n    '''\n    try:\n        return ((head[0]-tail[0])**2 + (head[1]-tail[1])**2)**0.5\n    except IndexError as e:\n        bt.logging.error(\"Input node structure not suitable for Euclidean 2D: {e}\")\ndef euc_3d(head:Iterable[Union[int,float]], tail:Iterable[Union[int,float]]):\n    '''",
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "euc_3d",
        "kind": 2,
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "peekOfCode": "def euc_3d(head:Iterable[Union[int,float]], tail:Iterable[Union[int,float]]):\n    '''\n    Computes the 3d euclidean distance of head vs tail\n    '''\n    try:\n        return ((head[0]-tail[0])**2 + (head[1]-tail[1])**2 + (head[2]-tail[2])**2)**0.5\n    except IndexError as e:\n        bt.logging.error(f\"Input node structure not suitable for Euclidean 2D: {e}\")\ndef geom(lat_lon_1:Iterable[Union[int, float]], lat_lon_2:Iterable[Union[int, float]]):\n    '''",
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "geom",
        "kind": 2,
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "peekOfCode": "def geom(lat_lon_1:Iterable[Union[int, float]], lat_lon_2:Iterable[Union[int, float]]):\n    '''\n    default settings for geom compute using WGS-84 format for coordinate values.\n    Refer to \"http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/TSPFAQ.html\" for geom dist definition\n    function requires the input values to be in (lat, lon) format.\n    '''\n    try:\n        q1 = math.cos(lat_lon_1[1] - lat_lon_2[1])\n        q2 = math.cos(lat_lon_1[0] - lat_lon_2[0])\n        q3 = math.cos(lat_lon_1[0] + lat_lon_2[0])",
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "man_2d",
        "kind": 2,
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "peekOfCode": "def man_2d(head:Iterable[Union[int,float]], tail:Iterable[Union[int,float]]):\n    '''\n    Computes the 2d manhattan distance of head vs tail\n    '''\n    try:\n        return abs(head[0]-tail[0]) + abs(head[1]-tail[1])\n    except IndexError as e:\n        bt.logging.error(\"Input node structure not suitable for Euclidean 2D: {e}\")\ndef man_3d(head:Iterable[Union[int,float]], tail:Iterable[Union[int,float]]):\n    '''",
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "man_3d",
        "kind": 2,
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "peekOfCode": "def man_3d(head:Iterable[Union[int,float]], tail:Iterable[Union[int,float]]):\n    '''\n    Computes the 3d manhattan distance of head vs tail\n    '''\n    try:\n        return abs(head[0]-tail[0]) + abs(head[1]-tail[1]) + abs(head[2]-tail[2])\n    except IndexError as e:\n        bt.logging.error(\"Input node structure not suitable for Manhattan 3D: {e}\")\ndef geom_edges(lat_lon_array):\n    '''",
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "geom_edges",
        "kind": 2,
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "peekOfCode": "def geom_edges(lat_lon_array):\n    '''\n    Vectorized geom distance calculation using numpy.\n    Requires lat_lon_array to be an Nx2 array where N is the number of nodes, \n    and the columns represent latitude and longitude respectively.\n    '''\n    lat_lon_array = np.deg2rad(lat_lon_array)\n    # Split latitudes and longitudes into separate arrays\n    lat = lat_lon_array[:, 0]  # All latitudes\n    lon = lat_lon_array[:, 1]  # All longitudes",
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "man_2d_edges",
        "kind": 2,
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "peekOfCode": "def man_2d_edges(lat_lon_array: np.ndarray) -> np.ndarray:\n    '''\n    Vectorized Manhattan distance calculation using numpy.\n    Requires lat_lon_array to be an Nx2 array where N is the number of nodes, \n    and the columns represent latitude and longitude respectively.\n    '''\n    # Split latitudes and longitudes into separate arrays\n    lat = lat_lon_array[:, 0]  # All latitudes\n    lon = lat_lon_array[:, 1]  # All longitudes\n    # Broadcast for pairwise distance computation",
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "euc_2d_edges",
        "kind": 2,
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "peekOfCode": "def euc_2d_edges(lat_lon_array: np.ndarray) -> np.ndarray:\n    '''\n    Vectorized Euclidean distance calculation using numpy.\n    Requires lat_lon_array to be an Nx2 array where N is the number of nodes, \n    and the columns represent latitude and longitude respectively.\n    '''\n    # Split latitudes and longitudes into separate arrays\n    lat = lat_lon_array[:, 0]  # All latitudes\n    lon = lat_lon_array[:, 1]  # All longitudes\n    # Broadcast for pairwise distance computation",
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "REF_PI",
        "kind": 5,
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "peekOfCode": "REF_PI = 3.141592\nREF_EARTH_RADIUS = 6378.388\n### Defining distance functions\ndef euc_2d(head:Iterable[Union[int,float]], tail:Iterable[Union[int,float]]):\n    '''\n    Computes the 2d euclidean distance of head vs tail\n    '''\n    try:\n        return ((head[0]-tail[0])**2 + (head[1]-tail[1])**2)**0.5\n    except IndexError as e:",
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "REF_EARTH_RADIUS",
        "kind": 5,
        "importPath": "graphite.data.distance",
        "description": "graphite.data.distance",
        "peekOfCode": "REF_EARTH_RADIUS = 6378.388\n### Defining distance functions\ndef euc_2d(head:Iterable[Union[int,float]], tail:Iterable[Union[int,float]]):\n    '''\n    Computes the 2d euclidean distance of head vs tail\n    '''\n    try:\n        return ((head[0]-tail[0])**2 + (head[1]-tail[1])**2)**0.5\n    except IndexError as e:\n        bt.logging.error(\"Input node structure not suitable for Euclidean 2D: {e}\")",
        "detail": "graphite.data.distance",
        "documentation": {}
    },
    {
        "label": "TransEncoderNet",
        "kind": 6,
        "importPath": "graphite.models.hybrid_pointer_network",
        "description": "graphite.models.hybrid_pointer_network",
        "peekOfCode": "class TransEncoderNet(nn.Module):\n    \"\"\"\n    Encoder network based on self-attention transformer\n    Inputs :\n      h of size      (bsz, nb_nodes+1, dim_emb)    batch of input cities\n    Outputs :\n      h of size      (bsz, nb_nodes+1, dim_emb)    batch of encoded cities\n      score of size  (bsz, nb_nodes+1, nb_nodes+1) batch of attention scores\n    \"\"\"\n    def __init__(self, nb_layers, dim_emb, nb_heads, dim_ff, batchnorm):",
        "detail": "graphite.models.hybrid_pointer_network",
        "documentation": {}
    },
    {
        "label": "Attention",
        "kind": 6,
        "importPath": "graphite.models.hybrid_pointer_network",
        "description": "graphite.models.hybrid_pointer_network",
        "peekOfCode": "class Attention(nn.Module):\n    def __init__(self, n_hidden):\n        super(Attention, self).__init__()\n        self.size = 0\n        self.batch_size = 0\n        self.dim = n_hidden\n        v  = torch.FloatTensor(n_hidden)\n        self.v  = nn.Parameter(v)\n        self.v.data.uniform_(-1/math.sqrt(n_hidden), 1/math.sqrt(n_hidden))\n        # parameters for pointer attention",
        "detail": "graphite.models.hybrid_pointer_network",
        "documentation": {}
    },
    {
        "label": "LSTM",
        "kind": 6,
        "importPath": "graphite.models.hybrid_pointer_network",
        "description": "graphite.models.hybrid_pointer_network",
        "peekOfCode": "class LSTM(nn.Module):\n    def __init__(self, n_hidden):\n        super(LSTM, self).__init__()\n        # parameters for input gate\n        self.Wxi = nn.Linear(n_hidden, n_hidden)    # W(xt)\n        self.Whi = nn.Linear(n_hidden, n_hidden)    # W(ht)\n        self.wci = nn.Linear(n_hidden, n_hidden)    # w(ct)\n        # parameters for forget gate\n        self.Wxf = nn.Linear(n_hidden, n_hidden)    # W(xt)\n        self.Whf = nn.Linear(n_hidden, n_hidden)    # W(ht)",
        "detail": "graphite.models.hybrid_pointer_network",
        "documentation": {}
    },
    {
        "label": "HPN",
        "kind": 6,
        "importPath": "graphite.models.hybrid_pointer_network",
        "description": "graphite.models.hybrid_pointer_network",
        "peekOfCode": "class HPN(nn.Module):\n    def __init__(self, n_feature, n_hidden):\n        super(HPN, self).__init__()\n        self.city_size = 0\n        self.batch_size = 0\n        self.dim = n_hidden\n        # pointer layer\n        self.pointer = Attention(n_hidden)\n        self.TransPointer = Attention(n_hidden)\n        # lstm encoder",
        "detail": "graphite.models.hybrid_pointer_network",
        "documentation": {}
    },
    {
        "label": "models_dir",
        "kind": 5,
        "importPath": "graphite.models.hybrid_pointer_network",
        "description": "graphite.models.hybrid_pointer_network",
        "peekOfCode": "models_dir = os.path.dirname(os.path.abspath(__file__))\nmodel_weight_dir = 'model_weights'\nCHECKPOINT_NAME = 'hpn_base_model.pkl'\nBASE_MODEL_CHECKPOINT = os.path.join(models_dir, model_weight_dir, CHECKPOINT_NAME)\nclass TransEncoderNet(nn.Module):\n    \"\"\"\n    Encoder network based on self-attention transformer\n    Inputs :\n      h of size      (bsz, nb_nodes+1, dim_emb)    batch of input cities\n    Outputs :",
        "detail": "graphite.models.hybrid_pointer_network",
        "documentation": {}
    },
    {
        "label": "model_weight_dir",
        "kind": 5,
        "importPath": "graphite.models.hybrid_pointer_network",
        "description": "graphite.models.hybrid_pointer_network",
        "peekOfCode": "model_weight_dir = 'model_weights'\nCHECKPOINT_NAME = 'hpn_base_model.pkl'\nBASE_MODEL_CHECKPOINT = os.path.join(models_dir, model_weight_dir, CHECKPOINT_NAME)\nclass TransEncoderNet(nn.Module):\n    \"\"\"\n    Encoder network based on self-attention transformer\n    Inputs :\n      h of size      (bsz, nb_nodes+1, dim_emb)    batch of input cities\n    Outputs :\n      h of size      (bsz, nb_nodes+1, dim_emb)    batch of encoded cities",
        "detail": "graphite.models.hybrid_pointer_network",
        "documentation": {}
    },
    {
        "label": "CHECKPOINT_NAME",
        "kind": 5,
        "importPath": "graphite.models.hybrid_pointer_network",
        "description": "graphite.models.hybrid_pointer_network",
        "peekOfCode": "CHECKPOINT_NAME = 'hpn_base_model.pkl'\nBASE_MODEL_CHECKPOINT = os.path.join(models_dir, model_weight_dir, CHECKPOINT_NAME)\nclass TransEncoderNet(nn.Module):\n    \"\"\"\n    Encoder network based on self-attention transformer\n    Inputs :\n      h of size      (bsz, nb_nodes+1, dim_emb)    batch of input cities\n    Outputs :\n      h of size      (bsz, nb_nodes+1, dim_emb)    batch of encoded cities\n      score of size  (bsz, nb_nodes+1, nb_nodes+1) batch of attention scores",
        "detail": "graphite.models.hybrid_pointer_network",
        "documentation": {}
    },
    {
        "label": "BASE_MODEL_CHECKPOINT",
        "kind": 5,
        "importPath": "graphite.models.hybrid_pointer_network",
        "description": "graphite.models.hybrid_pointer_network",
        "peekOfCode": "BASE_MODEL_CHECKPOINT = os.path.join(models_dir, model_weight_dir, CHECKPOINT_NAME)\nclass TransEncoderNet(nn.Module):\n    \"\"\"\n    Encoder network based on self-attention transformer\n    Inputs :\n      h of size      (bsz, nb_nodes+1, dim_emb)    batch of input cities\n    Outputs :\n      h of size      (bsz, nb_nodes+1, dim_emb)    batch of encoded cities\n      score of size  (bsz, nb_nodes+1, nb_nodes+1) batch of attention scores\n    \"\"\"",
        "detail": "graphite.models.hybrid_pointer_network",
        "documentation": {}
    },
    {
        "label": "BaseSolver",
        "kind": 6,
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "peekOfCode": "class BaseSolver(ABC):\n    def __init__(self, problem_types:List[Union[GraphV1Problem, GraphV2Problem, GraphV2ProblemMulti, GraphV2ProblemMultiConstrained, GraphV1PortfolioProblem]]):\n        self.problem_types = [problem.problem_type for problem in problem_types] # defining what problems the solver is equipped to solve\n        self.future_tracker = {}\n    #TODO evolve the abstract method to handle the different problem classes and objective functions\n    @abstractmethod\n    async def solve(self, formatted_problem, future_id, *args, **kwargs)->List[int]:\n        '''\n        Abstract class that handles the solving of GraphV1Problems contained within the Synapse.\n        Solvers can be developed to handle multiple types of graph traversal problems.",
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "DEFAULT_SOLVER_TIMEOUT",
        "kind": 5,
        "importPath": "graphite.solvers.base_solver",
        "description": "graphite.solvers.base_solver",
        "peekOfCode": "DEFAULT_SOLVER_TIMEOUT = 20\nclass BaseSolver(ABC):\n    def __init__(self, problem_types:List[Union[GraphV1Problem, GraphV2Problem, GraphV2ProblemMulti, GraphV2ProblemMultiConstrained, GraphV1PortfolioProblem]]):\n        self.problem_types = [problem.problem_type for problem in problem_types] # defining what problems the solver is equipped to solve\n        self.future_tracker = {}\n    #TODO evolve the abstract method to handle the different problem classes and objective functions\n    @abstractmethod\n    async def solve(self, formatted_problem, future_id, *args, **kwargs)->List[int]:\n        '''\n        Abstract class that handles the solving of GraphV1Problems contained within the Synapse.",
        "detail": "graphite.solvers.base_solver",
        "documentation": {}
    },
    {
        "label": "BeamSearchSolver",
        "kind": 6,
        "importPath": "graphite.solvers.beam_solver",
        "description": "graphite.solvers.beam_solver",
        "peekOfCode": "class BeamSearchSolver(BaseSolver):\n    def __init__(self, problem_types:List[Union[GraphV1Problem, GraphV2Problem]]=[GraphV1Problem(n_nodes=2), GraphV1Problem(n_nodes=2, directed=True, problem_type='General TSP')]):\n        super().__init__(problem_types=problem_types)\n    async def solve(self, formatted_problem, future_id:int, beam_width:int=3)->List[int]:\n        distance_matrix = formatted_problem\n        n = len(distance_matrix[0])\n        # Initialize the beam with the starting point (0) and a total distance of 0\n        beam = [(0, [0], 0)]\n        for _ in range(n - 1):\n            if self.future_tracker.get(future_id):",
        "detail": "graphite.solvers.beam_solver",
        "documentation": {}
    },
    {
        "label": "DPSolver",
        "kind": 6,
        "importPath": "graphite.solvers.exact_solver",
        "description": "graphite.solvers.exact_solver",
        "peekOfCode": "class DPSolver(BaseSolver):\n    def __init__(self, problem_types:List[Union[GraphV1Problem, GraphV2Problem]]=[GraphV1Problem(n_nodes=2), GraphV1Problem(n_nodes=2, directed=True, problem_type='General TSP')]):\n        super().__init__(problem_types=problem_types)\n    async def solve(self, formatted_problem, future_id:int)->List[int]:\n        distance_matrix = formatted_problem\n        if not self.is_solvable(distance_matrix):\n            return False\n        n = len(distance_matrix)\n        memo = {}\n        async def visit(visited, current):",
        "detail": "graphite.solvers.exact_solver",
        "documentation": {}
    },
    {
        "label": "GreedyPortfolioSolver",
        "kind": 6,
        "importPath": "graphite.solvers.greedy_portfolio_solver",
        "description": "graphite.solvers.greedy_portfolio_solver",
        "peekOfCode": "class GreedyPortfolioSolver(BaseSolver):\n    '''\n    This solver is a constructive nearest_neighbour algorithm that assigns cities to subtours based on the min increase in objective function value.\n    '''\n    def __init__(self, problem_types:List[GraphV1PortfolioProblem]=[GraphV1PortfolioProblem()]):\n        super().__init__(problem_types=problem_types)\n    def get_valid_start(self, depot_id, distance_matrix, taken_nodes:list[int]=[], selection_range:int=5) -> int:\n        distances = [(city_id, distance) for city_id, distance in enumerate(distance_matrix[depot_id].copy())]\n        # reverse sort the copied list and pop from it\n        assert (selection_range + len(taken_nodes)) < len(distances)",
        "detail": "graphite.solvers.greedy_portfolio_solver",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolver",
        "kind": 6,
        "importPath": "graphite.solvers.greedy_solver",
        "description": "graphite.solvers.greedy_solver",
        "peekOfCode": "class NearestNeighbourSolver(BaseSolver):\n    def __init__(self, problem_types:List[Union[GraphV1Problem, GraphV2Problem]]=[GraphV1Problem(n_nodes=2), GraphV1Problem(n_nodes=2, directed=True, problem_type='General TSP')]):\n        super().__init__(problem_types=problem_types)\n    async def solve(self, formatted_problem, future_id:int)->List[int]:\n        distance_matrix = formatted_problem\n        n = len(distance_matrix[0])\n        visited = [False] * n\n        route = []\n        total_distance = 0\n        current_node = 0",
        "detail": "graphite.solvers.greedy_solver",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver",
        "kind": 6,
        "importPath": "graphite.solvers.greedy_solver_multi",
        "description": "graphite.solvers.greedy_solver_multi",
        "peekOfCode": "class NearestNeighbourMultiSolver(BaseSolver):\n    def __init__(self, problem_types:List[GraphV2Problem]=[GraphV2ProblemMulti()]):\n        super().__init__(problem_types=problem_types)\n    async def solve(self, formatted_problem, future_id:int)->List[int]:\n        def split_into_sublists(original_list, n_salesmen):\n            n = len(original_list)\n            sublist_size = n // n_salesmen  # Size of each sublist\n            remainder = n % n_salesmen       # Remainder to distribute\n            sublists = []\n            start_index = 0",
        "detail": "graphite.solvers.greedy_solver_multi",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver2",
        "kind": 6,
        "importPath": "graphite.solvers.greedy_solver_multi_2",
        "description": "graphite.solvers.greedy_solver_multi_2",
        "peekOfCode": "class NearestNeighbourMultiSolver2(BaseSolver):\n    '''\n    This solver is a constructive nearest_neighbour algorithm that assigns cities to subtours based on the min increase in objective function value.\n    '''\n    def __init__(self, problem_types:List[GraphV2Problem]=[GraphV2ProblemMulti()]):\n        super().__init__(problem_types=problem_types)\n    def get_random_valid_start(self, depot_id, distance_matrix, taken_nodes:list[int]=[], selection_range:int=5) -> int:\n        distances = [(city_id, distance) for city_id, distance in enumerate(distance_matrix[depot_id].copy())]\n        # reverse sort the copied list and pop from it\n        assert (selection_range + len(taken_nodes)) < len(distances)",
        "detail": "graphite.solvers.greedy_solver_multi_2",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver3",
        "kind": 6,
        "importPath": "graphite.solvers.greedy_solver_multi_3",
        "description": "graphite.solvers.greedy_solver_multi_3",
        "peekOfCode": "class NearestNeighbourMultiSolver3(BaseSolver):\n    '''\n    This solver is a constructive nearest_neighbour algorithm that assigns cities to subtours based on the min increase in objective function value.\n    '''\n    def __init__(self, problem_types:List[GraphV2Problem]=[GraphV2ProblemMultiConstrained()]):\n        super().__init__(problem_types=problem_types)\n    def get_random_valid_start(self, depot_id, distance_matrix, taken_nodes:list[int]=[], selection_range:int=5) -> int:\n        distances = [(city_id, distance) for city_id, distance in enumerate(distance_matrix[depot_id].copy())]\n        # reverse sort the copied list and pop from it\n        assert (selection_range + len(taken_nodes)) < len(distances)",
        "detail": "graphite.solvers.greedy_solver_multi_3",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourMultiSolver4",
        "kind": 6,
        "importPath": "graphite.solvers.greedy_solver_multi_4",
        "description": "graphite.solvers.greedy_solver_multi_4",
        "peekOfCode": "class NearestNeighbourMultiSolver4(BaseSolver):\n    '''\n    This solver is a constructive nearest_neighbour algorithm that assigns cities to subtours based on the min increase in objective function value.\n    '''\n    def __init__(self, problem_types:List[GraphV2Problem]=[GraphV2ProblemMultiConstrained()]):\n        super().__init__(problem_types=problem_types)\n    def get_valid_start(self, depot_id, distance_matrix, taken_nodes:list[int]=[], selection_range:int=5) -> int:\n        distances = [(city_id, distance) for city_id, distance in enumerate(distance_matrix[depot_id].copy())]\n        # reverse sort the copied list and pop from it\n        assert (selection_range + len(taken_nodes)) < len(distances)",
        "detail": "graphite.solvers.greedy_solver_multi_4",
        "documentation": {}
    },
    {
        "label": "NearestNeighbourSolverVali",
        "kind": 6,
        "importPath": "graphite.solvers.greedy_solver_vali",
        "description": "graphite.solvers.greedy_solver_vali",
        "peekOfCode": "class NearestNeighbourSolverVali(BaseSolver):\n    def __init__(self, problem_types:List[Union[GraphV1Problem, GraphV2Problem]]=[GraphV1Problem(n_nodes=2), GraphV1Problem(n_nodes=2, directed=True, problem_type='General TSP')]):\n        super().__init__(problem_types=problem_types)\n    async def solve(self, formatted_problem, future_id:int)->List[int]:\n        distance_matrix = formatted_problem\n        n = len(distance_matrix[0])\n        visited = [False] * n\n        route = []\n        total_distance = 0\n        current_node = 0",
        "detail": "graphite.solvers.greedy_solver_vali",
        "documentation": {}
    },
    {
        "label": "HPNSolver",
        "kind": 6,
        "importPath": "graphite.solvers.hpn_solver",
        "description": "graphite.solvers.hpn_solver",
        "peekOfCode": "class HPNSolver(BaseSolver):\n    '''\n    implement solve method and necessary transformations\n    '''\n    def __init__(self, problem_types:List[Union[GraphV1Problem]]=[GraphV1Problem(n_nodes=2)], weights_fp:str = 'graphite/models/model_weights/hpn_base_model.pkl'):\n        super().__init__(problem_types=problem_types)\n        self.device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu') # assign device to run the model on\n        self.critic = HPN(n_feature=2, n_hidden=128) # instantiate model to handle metric 2-d geographic TSP problems\n        self.critic = self.critic.to(self.device)\n        self.critic.eval() # set the model to evaluate",
        "detail": "graphite.solvers.hpn_solver",
        "documentation": {}
    },
    {
        "label": "InsertionMultiSolver",
        "kind": 6,
        "importPath": "graphite.solvers.insertion_solver_multi",
        "description": "graphite.solvers.insertion_solver_multi",
        "peekOfCode": "class InsertionMultiSolver(BaseSolver):\n    '''\n    This solver is a constructive nearest_neighbour algorithm that assigns cities to subtours based on the min increase in objective function value.\n    '''\n    def __init__(self, problem_types:List[GraphV2Problem]=[GraphV2ProblemMulti()]):\n        super().__init__(problem_types=problem_types)\n    def get_random_valid_start(self, depot_id, distance_matrix, taken_nodes:list[int]=[], selection_range:int=5) -> int:\n        distances = [(city_id, distance) for city_id, distance in enumerate(distance_matrix[depot_id].copy())]\n        # reverse sort the copied list and pop from it\n        assert (selection_range + len(taken_nodes)) < len(distances)",
        "detail": "graphite.solvers.insertion_solver_multi",
        "documentation": {}
    },
    {
        "label": "NaiveMultiSolver",
        "kind": 6,
        "importPath": "graphite.solvers.naive_v2_multi_solver",
        "description": "graphite.solvers.naive_v2_multi_solver",
        "peekOfCode": "class NaiveMultiSolver(BaseSolver):\n    '''\n    Mock solver for comparison. Returns the route as per the random selection.\n    '''\n    def __init__(self, problem_types:List[GraphV2ProblemMulti]=[GraphV2ProblemMulti()]):\n        super().__init__(problem_types=problem_types)\n    async def solve(self, formatted_problem, future_id:int)->List[int]:\n        # naively split \n        m = formatted_problem.n_salesmen\n        n = formatted_problem.n_nodes",
        "detail": "graphite.solvers.naive_v2_multi_solver",
        "documentation": {}
    },
    {
        "label": "split_into_sublists",
        "kind": 2,
        "importPath": "graphite.solvers.naive_v2_multi_solver",
        "description": "graphite.solvers.naive_v2_multi_solver",
        "peekOfCode": "def split_into_sublists(lst, m):\n    # Shuffle the list to ensure randomness\n    random.shuffle(lst)\n    # Calculate the size of each sublist\n    k, r = divmod(len(lst), m)\n    # Create sublists\n    sublists = [lst[i * k + min(i, r):(i + 1) * k + min(i + 1, r)] for i in range(m)]\n    return sublists\nclass NaiveMultiSolver(BaseSolver):\n    '''",
        "detail": "graphite.solvers.naive_v2_multi_solver",
        "documentation": {}
    },
    {
        "label": "NaiveSolver",
        "kind": 6,
        "importPath": "graphite.solvers.naive_v2_solver",
        "description": "graphite.solvers.naive_v2_solver",
        "peekOfCode": "class NaiveSolver(BaseSolver):\n    '''\n    Mock solver for comparison. Returns the route as per the random selection.\n    '''\n    def __init__(self, problem_types:List[Union[GraphV2Problem]]=[GraphV2Problem()]):\n        super().__init__(problem_types=problem_types)\n    async def solve(self, formatted_problem, future_id:int)->List[int]:\n        route = formatted_problem\n        return route\n    def problem_transformations(self, problem: Union[GraphV2Problem]):",
        "detail": "graphite.solvers.naive_v2_solver",
        "documentation": {}
    },
    {
        "label": "is_cuda_available",
        "kind": 2,
        "importPath": "graphite.utils.config",
        "description": "graphite.utils.config",
        "peekOfCode": "def is_cuda_available():\n    try:\n        output = subprocess.check_output([\"nvidia-smi\", \"-L\"], stderr=subprocess.STDOUT)\n        if \"NVIDIA\" in output.decode(\"utf-8\"):\n            return \"cuda\"\n    except Exception:\n        pass\n    try:\n        output = subprocess.check_output([\"nvcc\", \"--version\"]).decode(\"utf-8\")\n        if \"release\" in output:",
        "detail": "graphite.utils.config",
        "documentation": {}
    },
    {
        "label": "check_config",
        "kind": 2,
        "importPath": "graphite.utils.config",
        "description": "graphite.utils.config",
        "peekOfCode": "def check_config(cls, config: \"bt.Config\"):\n    r\"\"\"Checks/validates the config namespace object.\"\"\"\n    bt.logging.check_config(config)\n    full_path = os.path.expanduser(\n        \"{}/{}/{}/netuid{}/{}\".format(\n            config.logging.logging_dir,  # TODO: change from ~/.bittensor/miners to ~/.bittensor/neurons\n            config.wallet.name,\n            config.wallet.hotkey,\n            config.netuid,\n            config.neuron.name,",
        "detail": "graphite.utils.config",
        "documentation": {}
    },
    {
        "label": "add_args",
        "kind": 2,
        "importPath": "graphite.utils.config",
        "description": "graphite.utils.config",
        "peekOfCode": "def add_args(cls, parser):\n    \"\"\"\n    Adds relevant arguments to the parser for operation.\n    \"\"\"\n    parser.add_argument(\"--netuid\", type=int, help=\"Subnet netuid\", default=1)\n    parser.add_argument(\n        \"--neuron.device\",\n        type=str,\n        help=\"Device to run on.\",\n        default=is_cuda_available(),",
        "detail": "graphite.utils.config",
        "documentation": {}
    },
    {
        "label": "add_miner_args",
        "kind": 2,
        "importPath": "graphite.utils.config",
        "description": "graphite.utils.config",
        "peekOfCode": "def add_miner_args(cls, parser):\n    \"\"\"Add miner specific arguments to the parser.\"\"\"\n    parser.add_argument(\n        \"--neuron.name\",\n        type=str,\n        help=\"Trials for this neuron go in neuron.root / (wallet_cold - wallet_hot) / neuron.name. \",\n        default=\"miner\",\n    )\n    parser.add_argument(\n        \"--blacklist.force_validator_permit\",",
        "detail": "graphite.utils.config",
        "documentation": {}
    },
    {
        "label": "add_validator_args",
        "kind": 2,
        "importPath": "graphite.utils.config",
        "description": "graphite.utils.config",
        "peekOfCode": "def add_validator_args(cls, parser):\n    \"\"\"Add validator specific arguments to the parser.\"\"\"\n    parser.add_argument(\n        \"--neuron.name\",\n        type=str,\n        help=\"Trials for this neuron go in neuron.root / (wallet_cold - wallet_hot) / neuron.name. \",\n        default=\"validator\",\n    )\n    parser.add_argument(\n        \"--neuron.timeout\",",
        "detail": "graphite.utils.config",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 2,
        "importPath": "graphite.utils.config",
        "description": "graphite.utils.config",
        "peekOfCode": "def config(cls):\n    \"\"\"\n    Returns the configuration object specific to this miner or validator after adding relevant arguments.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    bt.wallet.add_args(parser)\n    bt.subtensor.add_args(parser)\n    bt.logging.add_args(parser)\n    bt.axon.add_args(parser)\n    cls.add_args(parser)",
        "detail": "graphite.utils.config",
        "documentation": {}
    },
    {
        "label": "BENCHMARK_SOLUTIONS",
        "kind": 5,
        "importPath": "graphite.utils.constants",
        "description": "graphite.utils.constants",
        "peekOfCode": "BENCHMARK_SOLUTIONS = {\n    'Metric TSP': NearestNeighbourSolver,\n    'General TSP': NearestNeighbourSolver,\n    'Metric mTSP': NearestNeighbourMultiSolver2,\n    'General mTSP': NearestNeighbourMultiSolver2,\n    'Metric cmTSP': NearestNeighbourMultiSolver4,\n    'General cmTSP': NearestNeighbourMultiSolver4,\n    'PortfolioReallocation': GreedyPortfolioSolver\n} # mapping benchmark solvers to each problem\nCOST_FUNCTIONS = {",
        "detail": "graphite.utils.constants",
        "documentation": {}
    },
    {
        "label": "COST_FUNCTIONS",
        "kind": 5,
        "importPath": "graphite.utils.constants",
        "description": "graphite.utils.constants",
        "peekOfCode": "COST_FUNCTIONS = {\n    'Metric TSP': get_tour_distance,\n    'General TSP': get_tour_distance,\n    'Metric mTSP': get_multi_minmax_tour_distance,\n    'General mTSP': get_multi_minmax_tour_distance,\n    'Metric cmTSP': get_multi_minmax_tour_distance,\n    'General cmTSP': get_multi_minmax_tour_distance,\n    'PortfolioReallocation': get_portfolio_distribution_similarity\n}\nHEURISTIC_SOLVERS = [NearestNeighbourSolver, BeamSearchSolver, HPNSolver]",
        "detail": "graphite.utils.constants",
        "documentation": {}
    },
    {
        "label": "HEURISTIC_SOLVERS",
        "kind": 5,
        "importPath": "graphite.utils.constants",
        "description": "graphite.utils.constants",
        "peekOfCode": "HEURISTIC_SOLVERS = [NearestNeighbourSolver, BeamSearchSolver, HPNSolver]\nEXACT_SOLVERS = [DPSolver]\nDEFAULT_REBALANCING_INFO_ENDPOINT = \"http://api.yield.taotrader.xyz/api/v1/validator/rebalancing_info\" # Base URL for v1 API calls\nDEFAULT_PERFORMANCE_INFO_ENDPOINT = \"http://api.yield.taotrader.xyz/api/v1/validator/performance_info\"\nDEFAULT_YIELD_PROVIDER = \"5GNAzXLXdX749B2ZXPzbromP3rgatDFUpFdHsNxrBKBfA1yi\" # Trusted signer of the organic data",
        "detail": "graphite.utils.constants",
        "documentation": {}
    },
    {
        "label": "EXACT_SOLVERS",
        "kind": 5,
        "importPath": "graphite.utils.constants",
        "description": "graphite.utils.constants",
        "peekOfCode": "EXACT_SOLVERS = [DPSolver]\nDEFAULT_REBALANCING_INFO_ENDPOINT = \"http://api.yield.taotrader.xyz/api/v1/validator/rebalancing_info\" # Base URL for v1 API calls\nDEFAULT_PERFORMANCE_INFO_ENDPOINT = \"http://api.yield.taotrader.xyz/api/v1/validator/performance_info\"\nDEFAULT_YIELD_PROVIDER = \"5GNAzXLXdX749B2ZXPzbromP3rgatDFUpFdHsNxrBKBfA1yi\" # Trusted signer of the organic data",
        "detail": "graphite.utils.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_REBALANCING_INFO_ENDPOINT",
        "kind": 5,
        "importPath": "graphite.utils.constants",
        "description": "graphite.utils.constants",
        "peekOfCode": "DEFAULT_REBALANCING_INFO_ENDPOINT = \"http://api.yield.taotrader.xyz/api/v1/validator/rebalancing_info\" # Base URL for v1 API calls\nDEFAULT_PERFORMANCE_INFO_ENDPOINT = \"http://api.yield.taotrader.xyz/api/v1/validator/performance_info\"\nDEFAULT_YIELD_PROVIDER = \"5GNAzXLXdX749B2ZXPzbromP3rgatDFUpFdHsNxrBKBfA1yi\" # Trusted signer of the organic data",
        "detail": "graphite.utils.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PERFORMANCE_INFO_ENDPOINT",
        "kind": 5,
        "importPath": "graphite.utils.constants",
        "description": "graphite.utils.constants",
        "peekOfCode": "DEFAULT_PERFORMANCE_INFO_ENDPOINT = \"http://api.yield.taotrader.xyz/api/v1/validator/performance_info\"\nDEFAULT_YIELD_PROVIDER = \"5GNAzXLXdX749B2ZXPzbromP3rgatDFUpFdHsNxrBKBfA1yi\" # Trusted signer of the organic data",
        "detail": "graphite.utils.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_YIELD_PROVIDER",
        "kind": 5,
        "importPath": "graphite.utils.constants",
        "description": "graphite.utils.constants",
        "peekOfCode": "DEFAULT_YIELD_PROVIDER = \"5GNAzXLXdX749B2ZXPzbromP3rgatDFUpFdHsNxrBKBfA1yi\" # Trusted signer of the organic data",
        "detail": "graphite.utils.constants",
        "documentation": {}
    },
    {
        "label": "is_valid_path",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def is_valid_path(path:List[int])->bool:\n    # a valid path should have at least 3 return values and return to the source\n    return (len(path)>=3) and (path[0]==path[-1])\ndef is_valid_null_path(path:List[int])->bool:\n    # a valid path should have at least 3 return values and return to the source\n    return (len(path)==2) and (path[0]==path[-1])\ndef is_valid_multi_path(paths: List[List[int]], depots: List[int], num_cities)->bool:\n    '''\n    Arguments:\n    paths: list of paths where each path is a list of nodes that start and end at the same node",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_null_path",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def is_valid_null_path(path:List[int])->bool:\n    # a valid path should have at least 3 return values and return to the source\n    return (len(path)==2) and (path[0]==path[-1])\ndef is_valid_multi_path(paths: List[List[int]], depots: List[int], num_cities)->bool:\n    '''\n    Arguments:\n    paths: list of paths where each path is a list of nodes that start and end at the same node\n    depots: list of nodes indicating the valid sources for each traveling salesman\n    Output:\n    boolean indicating if the paths are valid or not",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_multi_path",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def is_valid_multi_path(paths: List[List[int]], depots: List[int], num_cities)->bool:\n    '''\n    Arguments:\n    paths: list of paths where each path is a list of nodes that start and end at the same node\n    depots: list of nodes indicating the valid sources for each traveling salesman\n    Output:\n    boolean indicating if the paths are valid or not\n    '''\n    assert len(paths) == len(depots), ValueError(\"Received unequal number of paths to depots. Note that if you choose to not use a salesman, you must still return a corresponding empty path: [depot, depot].\")\n    # check that each subpath is valid --> \"empty\" paths must be represented as [depot, depot]",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_tour_distance",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def get_tour_distance(synapse:Union[GraphV1Synapse, GraphV2Synapse])->float:\n    '''\n    Returns the total tour distance for the TSP problem as a float.\n    Takes a synapse as its only argument\n    '''\n    problem = synapse.problem\n    if 'TSP' not in problem.problem_type:\n        raise ValueError(f\"get_tour_distance is an invalid function for processing {problem.problem_type}\")\n    if not synapse.solution:\n        return np.inf",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_minmax_tour_distance",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def get_multi_minmax_tour_distance(synapse: GraphV2Synapse)->float:\n    '''\n    Returns the maximum tour distance across salesmen for the mTSP as a float.\n    Takes a synapse as its only argument\n    '''\n    problem = synapse.problem\n    if 'mTSP' not in problem.problem_type:\n        raise ValueError(f\"get_multi_tour_distance is an invalid function for processing {problem.problem_type}\")\n    if not synapse.solution:\n        return np.inf",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "get_portfolio_distribution_similarity",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def get_portfolio_distribution_similarity(synapse: GraphV1PortfolioSynapse):\n    '''\n    Returns the number of swaps and objective score\n    Takes a synapse as its only argument\n    '''\n    problem = synapse.problem\n    if not synapse.solution:\n        print(\"Solution not found\")\n        return 1000000, 0\n    swaps = synapse.solution",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "normalize_coordinates",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def normalize_coordinates(coordinates:List[List[Union[int,float]]]):\n    '''\n    Normalizes all coordinates against the max x or y value.\n    Normalized coordinate values are required my some open-source algorithms/models.\n    Assumes all coordinates are non-negative (in line with the current GraphV1Problem Formulation)\n    '''\n    coordinate_arr = np.array(coordinates)\n    max_val = 0\n    if np.max(coordinate_arr) != np.inf:\n        max_val = np.max(coordinate_arr)",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "generate_city_coordinates",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def generate_city_coordinates(n_cities, grid_size=1000):\n    '''\n    Helper function for generating random coordinates for MetricTSP problems.\n    '''\n    # Create a grid of coordinates\n    x = np.arange(grid_size)\n    y = np.arange(grid_size)\n    xv, yv = np.meshgrid(x, y)\n    coordinates = np.column_stack((xv.ravel(), yv.ravel()))\n    # Sample n_cities coordinates from the grid",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "check_nodes",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def check_nodes(solution:List[int], n_cities:int):\n    return not set(solution).difference(set(list(range(n_cities)))) and not set(list(range(n_cities))).difference(set(solution))\ndef start_and_end(solution:List[int]):\n    return solution[0] == solution[-1]\ndef is_valid_solution(problem:Union[GraphV1Problem, GraphV2Problem, GraphV2ProblemMulti, GraphV2ProblemMultiConstrained, GraphV1PortfolioProblem], solution:Union[List[List[Union[float, int]]],List[int]]):\n    # nested function to validate solution type\n    def is_valid_solution_type(solution, problem_type):\n        try:\n            assert isinstance(solution, list)\n            if \"mTSP\" in problem_type:",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "start_and_end",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def start_and_end(solution:List[int]):\n    return solution[0] == solution[-1]\ndef is_valid_solution(problem:Union[GraphV1Problem, GraphV2Problem, GraphV2ProblemMulti, GraphV2ProblemMultiConstrained, GraphV1PortfolioProblem], solution:Union[List[List[Union[float, int]]],List[int]]):\n    # nested function to validate solution type\n    def is_valid_solution_type(solution, problem_type):\n        try:\n            assert isinstance(solution, list)\n            if \"mTSP\" in problem_type:\n                assert all(isinstance(row, list) and all(isinstance(x, int) for x in row) for row in solution)\n            elif \"TSP\" in problem_type:",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_solution",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def is_valid_solution(problem:Union[GraphV1Problem, GraphV2Problem, GraphV2ProblemMulti, GraphV2ProblemMultiConstrained, GraphV1PortfolioProblem], solution:Union[List[List[Union[float, int]]],List[int]]):\n    # nested function to validate solution type\n    def is_valid_solution_type(solution, problem_type):\n        try:\n            assert isinstance(solution, list)\n            if \"mTSP\" in problem_type:\n                assert all(isinstance(row, list) and all(isinstance(x, int) for x in row) for row in solution)\n            elif \"TSP\" in problem_type:\n                assert all(isinstance(row, int) for row in solution)\n            elif \"PortfolioReallocation\" in problem_type:",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "is_valid_portfolio_solution",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def is_valid_portfolio_solution(problem:Union[GraphV1PortfolioProblem], solution):\n    if not all([len(swap)==4 for swap in solution]):\n        return False\n    if not all([swap[0]<problem.n_portfolio for swap in solution]):\n        return False\n    if not all([swap[1]<len(problem.pools) for swap in solution]):\n        return False\n    if not all([swap[2]<len(problem.pools) for swap in solution]):\n        return False\n    return True",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "valid_problem",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def valid_problem(problem:Union[GraphV1Problem, GraphV2Problem, GraphV1PortfolioProblem])->bool:\n    if problem.problem_type == 'Metric TSP':\n        if (problem.directed==False) and (problem.visit_all==True) and (problem.to_origin==True) and (problem.objective_function=='min'):\n            return True\n        else:\n            bt.logging.info(f\"Received an invalid Metric TSP problem\")\n            bt.logging.info(problem.get_info(verbosity=2))\n            return False\n    elif problem.problem_type == 'General TSP':\n        if (problem.directed==True) and (problem.visit_all==True) and (problem.to_origin==True) and (problem.objective_function=='min'):",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "timeout",
        "kind": 2,
        "importPath": "graphite.utils.graph_utils",
        "description": "graphite.utils.graph_utils",
        "peekOfCode": "def timeout(seconds=30, error_message=\"Solver timed out\"):\n    '''\n    basic implementation of async function timeout.\n    '''\n    def decorator(func):\n        @wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            try:\n                start_time = time.time()\n                result = await asyncio.wait_for(func(*args, **kwargs), timeout=seconds)",
        "detail": "graphite.utils.graph_utils",
        "documentation": {}
    },
    {
        "label": "setup_events_logger",
        "kind": 2,
        "importPath": "graphite.utils.logging",
        "description": "graphite.utils.logging",
        "peekOfCode": "def setup_events_logger(full_path, events_retention_size):\n    logging.addLevelName(EVENTS_LEVEL_NUM, \"EVENT\")\n    logger = logging.getLogger(\"event\")\n    logger.setLevel(EVENTS_LEVEL_NUM)\n    def event(self, message, *args, **kws):\n        if self.isEnabledFor(EVENTS_LEVEL_NUM):\n            self._log(EVENTS_LEVEL_NUM, message, args, **kws)\n    logging.Logger.event = event\n    formatter = logging.Formatter(\n        \"%(asctime)s | %(levelname)s | %(message)s\",",
        "detail": "graphite.utils.logging",
        "documentation": {}
    },
    {
        "label": "EVENTS_LEVEL_NUM",
        "kind": 5,
        "importPath": "graphite.utils.logging",
        "description": "graphite.utils.logging",
        "peekOfCode": "EVENTS_LEVEL_NUM = 38\nDEFAULT_LOG_BACKUP_COUNT = 10\ndef setup_events_logger(full_path, events_retention_size):\n    logging.addLevelName(EVENTS_LEVEL_NUM, \"EVENT\")\n    logger = logging.getLogger(\"event\")\n    logger.setLevel(EVENTS_LEVEL_NUM)\n    def event(self, message, *args, **kws):\n        if self.isEnabledFor(EVENTS_LEVEL_NUM):\n            self._log(EVENTS_LEVEL_NUM, message, args, **kws)\n    logging.Logger.event = event",
        "detail": "graphite.utils.logging",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LOG_BACKUP_COUNT",
        "kind": 5,
        "importPath": "graphite.utils.logging",
        "description": "graphite.utils.logging",
        "peekOfCode": "DEFAULT_LOG_BACKUP_COUNT = 10\ndef setup_events_logger(full_path, events_retention_size):\n    logging.addLevelName(EVENTS_LEVEL_NUM, \"EVENT\")\n    logger = logging.getLogger(\"event\")\n    logger.setLevel(EVENTS_LEVEL_NUM)\n    def event(self, message, *args, **kws):\n        if self.isEnabledFor(EVENTS_LEVEL_NUM):\n            self._log(EVENTS_LEVEL_NUM, message, args, **kws)\n    logging.Logger.event = event\n    formatter = logging.Formatter(",
        "detail": "graphite.utils.logging",
        "documentation": {}
    },
    {
        "label": "ttl_cache",
        "kind": 2,
        "importPath": "graphite.utils.misc",
        "description": "graphite.utils.misc",
        "peekOfCode": "def ttl_cache(maxsize: int = 128, typed: bool = False, ttl: int = -1):\n    \"\"\"\n    Decorator that creates a cache of the most recently used function calls with a time-to-live (TTL) feature.\n    The cache evicts the least recently used entries if the cache exceeds the `maxsize` or if an entry has\n    been in the cache longer than the `ttl` period.\n    Args:\n        maxsize (int): Maximum size of the cache. Once the cache grows to this size, subsequent entries\n                       replace the least recently used ones. Defaults to 128.\n        typed (bool): If set to True, arguments of different types will be cached separately. For example,\n                      f(3) and f(3.0) will be treated as distinct calls with distinct results. Defaults to False.",
        "detail": "graphite.utils.misc",
        "documentation": {}
    },
    {
        "label": "ttl_get_block",
        "kind": 2,
        "importPath": "graphite.utils.misc",
        "description": "graphite.utils.misc",
        "peekOfCode": "def ttl_get_block(self) -> int:\n    \"\"\"\n    Retrieves the current block number from the blockchain. This method is cached with a time-to-live (TTL)\n    of 12 seconds, meaning that it will only refresh the block number from the blockchain at most every 12 seconds,\n    reducing the number of calls to the underlying blockchain interface.\n    Returns:\n        int: The current block number on the blockchain.\n    This method is useful for applications that need to access the current block number frequently and can\n    tolerate a delay of up to 12 seconds for the latest information. By using a cache with TTL, the method\n    efficiently reduces the workload on the blockchain interface.",
        "detail": "graphite.utils.misc",
        "documentation": {}
    },
    {
        "label": "check_uid_availability",
        "kind": 2,
        "importPath": "graphite.utils.uids",
        "description": "graphite.utils.uids",
        "peekOfCode": "def check_uid_availability(\n    metagraph: \"bt.metagraph.Metagraph\", uid: int, vpermit_tao_limit: int\n) -> bool:\n    \"\"\"Check if uid is available. The UID should be available if it is serving and has less than vpermit_tao_limit stake\n    Args:\n        metagraph (:obj: bt.metagraph.Metagraph): Metagraph object\n        uid (int): uid to be checked\n        vpermit_tao_limit (int): Validator permit tao limit\n    Returns:\n        bool: True if uid is available, False otherwise",
        "detail": "graphite.utils.uids",
        "documentation": {}
    },
    {
        "label": "get_available_uids",
        "kind": 2,
        "importPath": "graphite.utils.uids",
        "description": "graphite.utils.uids",
        "peekOfCode": "def get_available_uids(\n    self, exclude: List[int] = None\n) -> torch.LongTensor:\n    \"\"\"Returns all available random uids from the metagraph.\n    Args:\n        exclude (List[int]): List of uids to exclude from the returned sample -- blacklisted miners.\n    Returns:\n        uids (torch.LongTensor): All available uids.\n    \"\"\"\n    candidate_uids = []",
        "detail": "graphite.utils.uids",
        "documentation": {}
    },
    {
        "label": "get_top_uids",
        "kind": 2,
        "importPath": "graphite.utils.uids",
        "description": "graphite.utils.uids",
        "peekOfCode": "def get_top_uids(\n    self, k: int, exclude: List[int] = None\n) -> torch.LongTensor:\n    \"\"\"Returns top k available random uids from the metagraph.\n    Args:\n        k (int): Number of uids to return.\n        exclude (List[int]): List of uids to exclude from the random sampling.\n    Returns:\n        uids (torch.LongTensor): top k sampled available uids.\n    Notes:",
        "detail": "graphite.utils.uids",
        "documentation": {}
    },
    {
        "label": "fetch_rebalancing_axon",
        "kind": 2,
        "importPath": "graphite.utils.yield_utils",
        "description": "graphite.utils.yield_utils",
        "peekOfCode": "def fetch_rebalancing_axon() -> Optional[bt.AxonInfo]:\n    # Fetch the yield axon from the yield endpoint\n    response = requests.get(f\"{DEFAULT_REBALANCING_INFO_ENDPOINT}\", timeout=10)\n    if response.status_code != 200:\n        bt.logging.error(f\"Failed to fetch rebalancing axon from {DEFAULT_REBALANCING_INFO_ENDPOINT}\")\n        return None\n    return bt.AxonInfo(**response.json())\ndef fetch_performance_axon() -> Optional[bt.AxonInfo]:\n    # Fetch the yield axon from the yield endpoint\n    response = requests.get(f\"{DEFAULT_PERFORMANCE_INFO_ENDPOINT}\", timeout=10)",
        "detail": "graphite.utils.yield_utils",
        "documentation": {}
    },
    {
        "label": "fetch_performance_axon",
        "kind": 2,
        "importPath": "graphite.utils.yield_utils",
        "description": "graphite.utils.yield_utils",
        "peekOfCode": "def fetch_performance_axon() -> Optional[bt.AxonInfo]:\n    # Fetch the yield axon from the yield endpoint\n    response = requests.get(f\"{DEFAULT_PERFORMANCE_INFO_ENDPOINT}\", timeout=10)\n    if response.status_code != 200:\n        bt.logging.error(f\"Failed to fetch performance axon from {DEFAULT_PERFORMANCE_INFO_ENDPOINT}\")\n        return None\n    return bt.AxonInfo(**response.json())",
        "detail": "graphite.utils.yield_utils",
        "documentation": {}
    },
    {
        "label": "ScoreResponse",
        "kind": 6,
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "peekOfCode": "class ScoreResponse:\n    def __init__(self, mock_synapse: Union[GraphV1Synapse, GraphV2Synapse]):\n        self.synapse = mock_synapse\n        self.problem = self.synapse.problem\n        # internally, validators apply a 30s timeout as the benchmark solution\n        # self.solver = NearestNeighbourSolverVali() # create instance of benchmark solver\n        self.solver = BENCHMARK_SOLUTIONS[self.problem.problem_type]() # create instance of benchmark solver\n        self.cost_function = COST_FUNCTIONS[self.problem.problem_type] # default cost function is \"get_tour_distance\" or \"get_multi_minmax_tour_distance\"\n        # asyncio.create_task(self.get_benchmark())\n        self._current_num_concurrent_forwards = 1",
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScorePortfolioResponse",
        "kind": 6,
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "peekOfCode": "class ScorePortfolioResponse:\n    def __init__(self, mock_synapse: Union[GraphV1PortfolioSynapse], solution):\n        self.synapse = mock_synapse\n        self.problem = self.synapse.problem\n        # internally, validators apply a 30s timeout as the benchmark solution\n        # self.solver = NearestNeighbourSolverVali() # create instance of benchmark solver\n        self.solver = BENCHMARK_SOLUTIONS[self.problem.problem_type]() # create instance of benchmark solver\n        self.cost_function = COST_FUNCTIONS[self.problem.problem_type] # default cost function is \"get_tour_distance\" or \"get_multi_minmax_tour_distance\"\n        # asyncio.create_task(self.get_benchmark())\n        self._current_num_concurrent_forwards = 1",
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "ScoreYieldResponse",
        "kind": 6,
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "peekOfCode": "class ScoreYieldResponse:\n    def __init__(self, mock_synapse: YieldDataRequestSynapse):\n        self.synapse = mock_synapse\n        self.weights = {\n            \"historical_daily_pnl\": 0.1, # We reward leaders for good recent performance\n            \"sharpe_ratio\": 0.55, # We want leaders to optimize for good stable returns\n            \"max_drawdown\": 0.1, # We also want to avoid large drawdowns\n            \"num_copy_traders\": 0.1, # We also want to reward leaders who have large impact on the copy trading community\n            \"notional_value_of_copy_traders\": 0.05,\n            \"volume\": 0.1 # We want to reward leaders who actively manage their portfolios which drives attributed volume",
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "is_approximately_equal",
        "kind": 2,
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "peekOfCode": "def is_approximately_equal(value1, value2, tolerance_percentage=0.00001):\n    # Handle infinite values explicitly\n    if np.isinf(value1) or np.isinf(value2):\n        return value1 == value2\n    # Calculate the absolute tolerance from the percentage\n    tolerance = tolerance_percentage / 100 * value1\n    return np.isclose(value1, value2, atol=tolerance)\ndef score_worse_than_reference(score, reference, objective_function):\n    if objective_function == \"min\":\n        if score > reference:",
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "score_worse_than_reference",
        "kind": 2,
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "peekOfCode": "def score_worse_than_reference(score, reference, objective_function):\n    if objective_function == \"min\":\n        if score > reference:\n            return True\n        else:\n            return False\n    else:\n        if score < reference:\n            return True\n        else:",
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "scaled_rewards",
        "kind": 2,
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "peekOfCode": "def scaled_rewards(scores, benchmark: float, objective_function:str = 'min'):\n    def score_gap(score, best_score, reference):\n        if is_approximately_equal(score, reference):\n            return 0.2 # matched the benchmark so assign a floor score\n        elif score_worse_than_reference(score, reference, objective_function):\n            return 0 # scored worse than the required benchmark\n        else:\n            # proportionally scale rewards based on the relative normalized scores\n            assert (not is_approximately_equal(best_score, reference) and not score_worse_than_reference(best_score, reference, objective_function)), ValueError(f\"Best score is worse than reference: best-{best_score}, ref-{reference}\")\n            return ((1 - abs(best_score-score)/abs(best_score-reference))**2)*0.8 + 0.2",
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "scaled_portfolio_rewards",
        "kind": 2,
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "peekOfCode": "def scaled_portfolio_rewards(scores, benchmark: any, objective_function:str = 'max'):\n    def score_gap(score, best_score, reference):\n        if is_approximately_equal(score, reference):\n            return 0.2 # matched the benchmark so assign a floor score\n        elif score_worse_than_reference(score, reference, objective_function):\n            return 0 # scored worse than the required benchmark\n        else:\n            # proportionally scale rewards based on the relative normalized scores\n            assert (not is_approximately_equal(best_score, reference) and not score_worse_than_reference(best_score, reference, objective_function)), ValueError(f\"Best score is worse than reference: best-{best_score}, ref-{reference}\")\n            return ((1 - abs(best_score-score)/abs(best_score-reference))**2)*0.8 + 0.2",
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "get_rewards",
        "kind": 2,
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "peekOfCode": "def get_rewards(\n    self,\n    score_handler: ScoreResponse,\n    responses: List[Union[GraphV1Synapse, GraphV2Synapse]],\n) -> torch.FloatTensor:\n    \"\"\"\n    Returns a tensor of rewards for the given query and responses.\n    Args:\n    - query (int): The query sent to the miner.\n    - responses (List[float]): A list of responses from the miner.",
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "get_portfolio_rewards",
        "kind": 2,
        "importPath": "graphite.validator.reward",
        "description": "graphite.validator.reward",
        "peekOfCode": "def get_portfolio_rewards(\n    self,\n    score_handler: ScorePortfolioResponse,\n    responses: List[Union[GraphV1PortfolioSynapse]],\n) -> torch.FloatTensor:\n    \"\"\"\n    Returns a tensor of rewards for the given query and responses.\n    Args:\n    - query (int): The query sent to the miner.\n    - responses (List[float]): A list of responses from the miner.",
        "detail": "graphite.validator.reward",
        "documentation": {}
    },
    {
        "label": "MockSubtensor",
        "kind": 6,
        "importPath": "graphite.mock",
        "description": "graphite.mock",
        "peekOfCode": "class MockSubtensor(bt.MockSubtensor):\n    def __init__(self, netuid, n=16, wallet=None, network=\"mock\"):\n        super().__init__(network=network)\n        if not self.subnet_exists(netuid):\n            self.create_subnet(netuid)\n        # Register ourself (the validator) as a neuron at uid=0\n        if wallet is not None:\n            self.force_register_neuron(\n                netuid=netuid,\n                hotkey=wallet.hotkey.ss58_address,",
        "detail": "graphite.mock",
        "documentation": {}
    },
    {
        "label": "MockMetagraph",
        "kind": 6,
        "importPath": "graphite.mock",
        "description": "graphite.mock",
        "peekOfCode": "class MockMetagraph(bt.metagraph):\n    def __init__(self, netuid=1, network=\"mock\", subtensor=None):\n        super().__init__(netuid=netuid, network=network, sync=False)\n        if subtensor is not None:\n            self.subtensor = subtensor\n        self.sync(subtensor=subtensor)\n        for axon in self.axons:\n            axon.ip = \"127.0.0.0\"\n            axon.port = 8091\n        bt.logging.info(f\"Metagraph: {self}\")",
        "detail": "graphite.mock",
        "documentation": {}
    },
    {
        "label": "MockDendrite",
        "kind": 6,
        "importPath": "graphite.mock",
        "description": "graphite.mock",
        "peekOfCode": "class MockDendrite(bt.dendrite):\n    \"\"\"\n    Replaces a real bittensor network request with a mock request that just returns some static response for all axons that are passed and adds some random delay.\n    \"\"\"\n    def __init__(self, wallet):\n        super().__init__(wallet)\n    async def forward(\n        self,\n        axons: List[bt.axon],\n        synapse: bt.Synapse = bt.Synapse(),",
        "detail": "graphite.mock",
        "documentation": {}
    },
    {
        "label": "OrganicPortfolioRequestSynapse",
        "kind": 6,
        "importPath": "graphite.organic_protocol",
        "description": "graphite.organic_protocol",
        "peekOfCode": "class OrganicPortfolioRequestSynapse(bt.Synapse):\n    # Sends out NULL problem and receives actual problem as a response | For now, we only accept GraphV1PortfolioProblem\n    problem: Optional[GraphV1PortfolioProblem] = None \n    job_id: Optional[str] = None # hash of the job\nclass OrganicPortfolioResponseSynapse(bt.Synapse):\n    # sends out synapse to trigger rebalancing on yield_server\n    problem: GraphV1PortfolioProblem\n    solution: Optional[Union[List[List[Union[int, float]]], bool]] = None\n    accepted: bool = False\n    job_id: Optional[str] = None # hash of the job",
        "detail": "graphite.organic_protocol",
        "documentation": {}
    },
    {
        "label": "OrganicPortfolioResponseSynapse",
        "kind": 6,
        "importPath": "graphite.organic_protocol",
        "description": "graphite.organic_protocol",
        "peekOfCode": "class OrganicPortfolioResponseSynapse(bt.Synapse):\n    # sends out synapse to trigger rebalancing on yield_server\n    problem: GraphV1PortfolioProblem\n    solution: Optional[Union[List[List[Union[int, float]]], bool]] = None\n    accepted: bool = False\n    job_id: Optional[str] = None # hash of the job",
        "detail": "graphite.organic_protocol",
        "documentation": {}
    },
    {
        "label": "IsAlive",
        "kind": 6,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "class IsAlive(bt.Synapse):\n    answer: Optional[str] = None\n    completion: str = Field(\n        \"\",\n        title=\"Completion\",\n        description=\"Checks if axon is alive.\"\n                    \"This attribute is mutable and can be updated.\",\n    )\n    def to_headers(self) -> dict:\n        \"\"\"",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioProblem",
        "kind": 6,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "class GraphV1PortfolioProblem(BaseModel):\n    problem_type: Literal['PortfolioReallocation'] = Field('PortfolioReallocation', description=\"Problem Type\")\n    n_portfolio: int = Field(3, description=\"Number of Portfolios\")\n    initialPortfolios: List[List[int]] = Field([[0]*100]*3, description=\"Number of tokens in each subnet for each of the n_portfolio eg. 3 portfolios with 0 tokens in any of the 100 subnets\")\n    constraintValues: List[Union[float, int]] = Field([1.0]*100, description=\"Overall Percentage for each subnet in equivalent TAO after taking the sum of all portfolios; they do not need to add up to 100%\")\n    constraintTypes: List[str] = Field([\"ge\"]*100, description=\"eq = equal to, ge = greater or equals to, le = lesser or equals to - the value provided in constraintValues\")\n    pools: List[List[int]] = Field([[1.0, 1.0]]*100, description=\"Snapshot of current AMM pool states of all subnets when problem is issued, list idx = netuid, [num_tao_tokens, num_alpha_tokens]\")\n    @model_validator(mode='after')\n    def assert_portfolio_count(self):\n        assert len(self.initialPortfolios) == self.n_portfolio, ValueError('Number of portfolio must match n_portfolio')",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1PortfolioSynapse",
        "kind": 6,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "class GraphV1PortfolioSynapse(bt.Synapse):\n    '''\n    Implement necessary serialization and deserialization checks\n    '''\n    problem: Union[GraphV1PortfolioProblem]\n    solution: Optional[Union[List[List[int]], bool]] = None  #[ [portfolio_idx, from_subnet_idx, to_subnet_idx, from_num_alpha_tokens], ... ]\n    def to_headers(self) -> dict:\n        \"\"\"\n        Converts the state of a Synapse instance into a dictionary of HTTP headers.\n        This method is essential for",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Problem",
        "kind": 6,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "class GraphV2Problem(BaseModel):\n    problem_type: Literal['Metric TSP', 'General TSP'] = Field('Metric TSP', description=\"Problem Type\")\n    objective_function: str = Field('min', description=\"Objective Function\")\n    visit_all: bool = Field(True, description=\"Visit All Nodes\")\n    to_origin: bool = Field(True, description=\"Return to Origin\")\n    n_nodes: conint(ge=2000, le=5000) = Field(2000, description=\"Number of Nodes (must be between 2000 and 5000)\")\n    selected_ids: List[int] = Field(default_factory=list, description=\"List of selected node positional indexes\")\n    cost_function: Literal['Geom', 'Euclidean2D', 'Manhatten2D', 'Euclidean3D', 'Manhatten3D'] = Field('Geom', description=\"Cost function\")\n    dataset_ref: Literal['Asia_MSB', 'World_TSP', 'USA_POI'] = Field('Asia_MSB', description=\"Dataset reference file\")\n    nodes: Union[List[List[Union[conint(ge=0), confloat(ge=0)]]], Iterable, None] = Field(default_factory=list, description=\"Node Coordinates\")  # If not none, nodes represent the coordinates of the cities",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMulti",
        "kind": 6,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "class GraphV2ProblemMulti(GraphV2Problem):\n    problem_type: Literal['Metric mTSP', 'General mTSP'] = Field('Metric mTSP', description=\"Problem Type\")\n    n_nodes: conint(ge=500, le=2000) = Field(500, description=\"Number of Nodes (must be between 500 and 2000) for mTSP\")\n    n_salesmen: conint(ge=2, le=MAX_SALESMEN) = Field(2, description=\"Number of Salesmen in the mTSP formulation\")\n    # Note that in this initial problem formulation, we will start with a single depot structure\n    single_depot: bool = Field(True, description=\"Whether problem is a single or multi depot formulation\")\n    depots: List[int] = Field([0,0], description=\"List of selected 'city' indices for which the respective salesmen paths begin\")\n    # dataset_ref: Literal['Asia_MSB', 'World_TSP', 'USA_POI'] = Field('Asia_MSB', description=\"Dataset reference file\")\n    ### Expensive check only needed for organic requests\n    # @model_validator(mode='after')",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2ProblemMultiConstrained",
        "kind": 6,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "class GraphV2ProblemMultiConstrained(GraphV2Problem):\n    problem_type: Literal['Metric cmTSP', 'General cmTSP'] = Field('Metric cmTSP', description=\"Problem Type\")\n    n_nodes: conint(ge=500, le=2000) = Field(500, description=\"Number of Nodes (must be between 500 and 2000) for mTSP\")\n    n_salesmen: conint(ge=2, le=MAX_SALESMEN) = Field(2, description=\"Number of Salesmen in the mTSP formulation\")\n    demand: List[int] = Field([1, 1], description=\"Demand of each node, we are starting with 1\")\n    constraint: List[int] = Field([100, 100], description=\"Constaint of each salesmen/delivery vehicle\")\n    single_depot: bool = Field(default=False, description=\"Whether problem is a single or multi depot formulation\")\n    depots: List[int] = Field([0,0], description=\"List of selected 'city' indices for which the respective salesmen paths begin\")\n    @model_validator(mode='after')\n    def assert_salesmen_depot(self):",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV2Synapse",
        "kind": 6,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "class GraphV2Synapse(bt.Synapse):\n    '''\n    Implement necessary serialization and deserialization checks\n    '''\n    problem: Union[GraphV2Problem, GraphV2ProblemMulti, GraphV2ProblemMultiConstrained]\n    solution: Optional[Union[List[List[int]], List[int], bool]] = None\n    def to_headers(self) -> dict:\n        \"\"\"\n        Converts the state of a Synapse instance into a dictionary of HTTP headers.\n        This method is essential for",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Problem",
        "kind": 6,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "class GraphV1Problem(BaseModel):\n    problem_type: Literal['Metric TSP', 'General TSP'] = Field('Metric TSP', description=\"Problem Type\")\n    objective_function: str = Field('min', description=\"Objective Function\")\n    visit_all: bool = Field(True, description=\"Visit All Nodes\")\n    to_origin: bool = Field(True, description=\"Return to Origin\")\n    n_nodes: conint(ge=2) = Field(10, description=\"Number of Nodes (must be >= 2)\")\n    nodes: Union[List[List[Union[conint(ge=0), confloat(ge=0)]]],None] = Field(default_factory=list, description=\"Node Coordinates\")  # If not none, nodes represent the coordinates of the cities\n    edges: Union[List[List[Union[conint(ge=0), confloat(ge=0)]]],None] = Field(default_factory=list, description=\"Edge Weights\")  # If not none, this represents a square matrix of edges where edges[source;row][destination;col] is the cost of a given edge\n    directed: bool = Field(False, description=\"Directed Graph\")  # boolean for whether the graph is directed or undirected / Symmetric or Asymmetric\n    simple: bool = Field(True, description=\"Simple Graph\")  # boolean for whether the graph contains any degenerate loop",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "GraphV1Synapse",
        "kind": 6,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "class GraphV1Synapse(bt.Synapse):\n    '''\n    Implement necessary serialization and deserialization checks\n    '''\n    problem: GraphV1Problem\n    solution: Optional[Union[List[int], bool]] = None\n    def to_headers(self) -> dict:\n        \"\"\"\n        Converts the state of a Synapse instance into a dictionary of HTTP headers.\n        This method is essential for",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "is_alive_path",
        "kind": 5,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "is_alive_path = os.path.join(os.path.dirname(__file__), \"is_alive.json\")\nwith open(is_alive_path, \"r\") as f:\n    ISALIVE_SCHEMA = json.load(f)\nrel_v1_path = os.path.join(os.path.dirname(__file__), \"schema_v1.json\")\nwith open(rel_v1_path, \"r\") as f:\n    MODEL_V1_SCHEMA = json.load(f)\nrel_v2_path = os.path.join(os.path.dirname(__file__), \"schema_v2.json\")\nwith open(rel_v2_path, \"r\") as f:\n    MODEL_V2_SCHEMA = json.load(f)\nrel_v3_path = os.path.join(os.path.dirname(__file__), \"schema_v3.json\")",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "rel_v1_path",
        "kind": 5,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "rel_v1_path = os.path.join(os.path.dirname(__file__), \"schema_v1.json\")\nwith open(rel_v1_path, \"r\") as f:\n    MODEL_V1_SCHEMA = json.load(f)\nrel_v2_path = os.path.join(os.path.dirname(__file__), \"schema_v2.json\")\nwith open(rel_v2_path, \"r\") as f:\n    MODEL_V2_SCHEMA = json.load(f)\nrel_v3_path = os.path.join(os.path.dirname(__file__), \"schema_v3.json\")\nwith open(rel_v3_path, \"r\") as f:\n    MODEL_V3_SCHEMA = json.load(f)\nclass IsAlive(bt.Synapse):",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "rel_v2_path",
        "kind": 5,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "rel_v2_path = os.path.join(os.path.dirname(__file__), \"schema_v2.json\")\nwith open(rel_v2_path, \"r\") as f:\n    MODEL_V2_SCHEMA = json.load(f)\nrel_v3_path = os.path.join(os.path.dirname(__file__), \"schema_v3.json\")\nwith open(rel_v3_path, \"r\") as f:\n    MODEL_V3_SCHEMA = json.load(f)\nclass IsAlive(bt.Synapse):\n    answer: Optional[str] = None\n    completion: str = Field(\n        \"\",",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "rel_v3_path",
        "kind": 5,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "rel_v3_path = os.path.join(os.path.dirname(__file__), \"schema_v3.json\")\nwith open(rel_v3_path, \"r\") as f:\n    MODEL_V3_SCHEMA = json.load(f)\nclass IsAlive(bt.Synapse):\n    answer: Optional[str] = None\n    completion: str = Field(\n        \"\",\n        title=\"Completion\",\n        description=\"Checks if axon is alive.\"\n                    \"This attribute is mutable and can be updated.\",",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "MAX_SALESMEN",
        "kind": 5,
        "importPath": "graphite.protocol",
        "description": "graphite.protocol",
        "peekOfCode": "MAX_SALESMEN = 10\nclass GraphV2ProblemMulti(GraphV2Problem):\n    problem_type: Literal['Metric mTSP', 'General mTSP'] = Field('Metric mTSP', description=\"Problem Type\")\n    n_nodes: conint(ge=500, le=2000) = Field(500, description=\"Number of Nodes (must be between 500 and 2000) for mTSP\")\n    n_salesmen: conint(ge=2, le=MAX_SALESMEN) = Field(2, description=\"Number of Salesmen in the mTSP formulation\")\n    # Note that in this initial problem formulation, we will start with a single depot structure\n    single_depot: bool = Field(True, description=\"Whether problem is a single or multi depot formulation\")\n    depots: List[int] = Field([0,0], description=\"List of selected 'city' indices for which the respective salesmen paths begin\")\n    # dataset_ref: Literal['Asia_MSB', 'World_TSP', 'USA_POI'] = Field('Asia_MSB', description=\"Dataset reference file\")\n    ### Expensive check only needed for organic requests",
        "detail": "graphite.protocol",
        "documentation": {}
    },
    {
        "label": "SUBNET_LINKS",
        "kind": 5,
        "importPath": "graphite.subnet_links",
        "description": "graphite.subnet_links",
        "peekOfCode": "SUBNET_LINKS = [\n    {\"name\": \"sn0\", \"url\": \"\"},\n    {\"name\": \"sn1\", \"url\": \"https://github.com/opentensor/prompting/\"},\n    {\"name\": \"sn2\", \"url\": \"https://github.com/bittranslateio/bittranslate/\"},\n    {\n        \"name\": \"sn3\",\n        \"url\": \"https://github.com/gitphantomman/scraping_subnet/\",\n    },\n    {\"name\": \"sn4\", \"url\": \"https://github.com/manifold-inc/targon/\"},\n    {\"name\": \"sn5\", \"url\": \"https://github.com/unconst/ImageSubnet/\"},",
        "detail": "graphite.subnet_links",
        "documentation": {}
    },
    {
        "label": "LeaderPerformanceData",
        "kind": 6,
        "importPath": "graphite.yield_protocol",
        "description": "graphite.yield_protocol",
        "peekOfCode": "class LeaderPerformanceData(BaseModel):\n    historical_daily_pnl: List[float] = Field(default_factory=list) # ordered by time\n    sharpe_ratio: float\n    max_drawdown: float\n    num_copy_traders: int\n    volume: int # volume in RAO of attributed rebalances\n    notional_value_of_copy_traders: float\n    last_traded_date: int # unix timestamp of last leader rebalance\nclass MinerYield(BaseModel):\n    uid: int",
        "detail": "graphite.yield_protocol",
        "documentation": {}
    },
    {
        "label": "MinerYield",
        "kind": 6,
        "importPath": "graphite.yield_protocol",
        "description": "graphite.yield_protocol",
        "peekOfCode": "class MinerYield(BaseModel):\n    uid: int\n    hotkey: str\n    yield_data: Optional[LeaderPerformanceData] = None\n    @field_validator('hotkey')\n    def validate_hotkey(cls, v):\n        if not is_valid_ss58_address(v):\n            raise ValueError(\"Invalid hotkey\")\n        return v\nclass YieldDataRequestSynapse(bt.Synapse):",
        "detail": "graphite.yield_protocol",
        "documentation": {}
    },
    {
        "label": "YieldDataRequestSynapse",
        "kind": 6,
        "importPath": "graphite.yield_protocol",
        "description": "graphite.yield_protocol",
        "peekOfCode": "class YieldDataRequestSynapse(bt.Synapse):\n    # Sends out NULL problem and receives actual problem as a response | For now, we only accept GraphV1PortfolioProblem\n    yields: List[MinerYield] = Field(default_factory=list)",
        "detail": "graphite.yield_protocol",
        "documentation": {}
    },
    {
        "label": "Miner",
        "kind": 6,
        "importPath": "neurons.miner",
        "description": "neurons.miner",
        "peekOfCode": "class Miner(BaseMinerNeuron):\n    \"\"\"\n    Your miner neuron class. You should use this class to define your miner's behavior. In particular, you should replace the forward function with your own logic. You may also want to override the blacklist and priority functions according to your needs.\n    This class inherits from the BaseMinerNeuron class, which in turn inherits from BaseNeuron. The BaseNeuron class takes care of routine tasks such as setting up wallet, subtensor, metagraph, logging directory, parsing config, etc. You can override any of the methods in BaseNeuron if you need to customize the behavior.\n    This class provides reasonable default behavior for a miner such as blacklisting unrecognized hotkeys, prioritizing requests based on stake, and forwarding requests to the forward function. If you need to define custom\n    \"\"\"\n    def __init__(self, config=None):\n        super(Miner, self).__init__(config=config)\n        self.axon.attach(\n            forward_fn=self.is_alive,",
        "detail": "neurons.miner",
        "documentation": {}
    },
    {
        "label": "Validator",
        "kind": 6,
        "importPath": "neurons.validator",
        "description": "neurons.validator",
        "peekOfCode": "class Validator(BaseValidatorNeuron):\n    \"\"\"\n    Your validator neuron class. You should use this class to define your validator's behavior. In particular, you should replace the forward function with your own logic.\n    This class inherits from the BaseValidatorNeuron class, which in turn inherits from BaseNeuron. The BaseNeuron class takes care of routine tasks such as setting up wallet, subtensor, metagraph, logging directory, parsing config, etc. You can override any of the methods in BaseNeuron if you need to customize the behavior.\n    This class provides reasonable default behavior for a validator such as keeping a moving average of the scores of the miners and using them to set weights at the end of each epoch. Additionally, the scores are reset for new hotkeys at the end of each epoch.\n    \"\"\"\n    def __init__(self, config=None):\n        super(Validator, self).__init__(config=config)\n        # bt.logging.info(\"load_state()\")\n        # self.load_state()",
        "detail": "neurons.validator",
        "documentation": {}
    },
    {
        "label": "Mock",
        "kind": 6,
        "importPath": "tests.unit_test.test_multi_depot_mtsp",
        "description": "tests.unit_test.test_multi_depot_mtsp",
        "peekOfCode": "class Mock:\n    def __init__(self): \n        pass\nclass MDMTSPSolutionEnum(Enum):\n    VALID = 0\n    TOO_FEW_CITIES = 1\n    TOO_MANY_CITIES = 2\n    REPEAT_CITIES = 3\n    INVALID_DEPOT = 4\n    WRONG_DEPOT_ORDER = 5",
        "detail": "tests.unit_test.test_multi_depot_mtsp",
        "documentation": {}
    },
    {
        "label": "MDMTSPSolutionEnum",
        "kind": 6,
        "importPath": "tests.unit_test.test_multi_depot_mtsp",
        "description": "tests.unit_test.test_multi_depot_mtsp",
        "peekOfCode": "class MDMTSPSolutionEnum(Enum):\n    VALID = 0\n    TOO_FEW_CITIES = 1\n    TOO_MANY_CITIES = 2\n    REPEAT_CITIES = 3\n    INVALID_DEPOT = 4\n    WRONG_DEPOT_ORDER = 5\n    VISITED_DEPOT = 6 # visit another depot which is invalid\n    DEPOT_TO_DEPOT = 7\n    NO_RETURN = 8",
        "detail": "tests.unit_test.test_multi_depot_mtsp",
        "documentation": {}
    },
    {
        "label": "TestScoringFunction",
        "kind": 6,
        "importPath": "tests.unit_test.test_multi_depot_mtsp",
        "description": "tests.unit_test.test_multi_depot_mtsp",
        "peekOfCode": "class TestScoringFunction(unittest.TestCase):\n    def setUp(self):\n        # create an md-mTSP instance\n        self.graph_problem = MetricMTSPV2Generator.generate_one_sample(mock.loaded_datasets, 2000, 4, single_depot=False)\n        self.graph_rp_depot_problem = copy.deepcopy(self.graph_problem)\n        self.graph_rp_depot_problem.depots[1] = self.graph_rp_depot_problem.depots[0]\n        self.graph_synapse = GraphV2Synapse(problem=self.graph_problem)\n        self.graph_synapse_rp = GraphV2Synapse(problem=self.graph_rp_depot_problem)\n        self.score_handler = ScoreResponse(self.graph_synapse)\n        self.score_handler_rp = ScoreResponse(self.graph_synapse_rp)",
        "detail": "tests.unit_test.test_multi_depot_mtsp",
        "documentation": {}
    },
    {
        "label": "generate_mdmtsp_test_response",
        "kind": 2,
        "importPath": "tests.unit_test.test_multi_depot_mtsp",
        "description": "tests.unit_test.test_multi_depot_mtsp",
        "peekOfCode": "def generate_mdmtsp_test_response(problem:GraphV2ProblemMulti, solution_type:MDMTSPSolutionEnum):\n    assert isinstance(solution_type, MDMTSPSolutionEnum)\n    n_nodes = problem.n_nodes\n    depots = problem.depots\n    def generate_random_initial_solution(n_nodes, depots):\n        # initialize start routes\n        routes = [[x,x] for x in depots]\n        remaining_cities = list(set(range(n_nodes)).difference(depots))\n        random.shuffle(remaining_cities)\n        route_indices = cycle(range(len(depots)))",
        "detail": "tests.unit_test.test_multi_depot_mtsp",
        "documentation": {}
    },
    {
        "label": "mock",
        "kind": 5,
        "importPath": "tests.unit_test.test_multi_depot_mtsp",
        "description": "tests.unit_test.test_multi_depot_mtsp",
        "peekOfCode": "mock = Mock()\nload_default_dataset(mock)\ndef generate_mdmtsp_test_response(problem:GraphV2ProblemMulti, solution_type:MDMTSPSolutionEnum):\n    assert isinstance(solution_type, MDMTSPSolutionEnum)\n    n_nodes = problem.n_nodes\n    depots = problem.depots\n    def generate_random_initial_solution(n_nodes, depots):\n        # initialize start routes\n        routes = [[x,x] for x in depots]\n        remaining_cities = list(set(range(n_nodes)).difference(depots))",
        "detail": "tests.unit_test.test_multi_depot_mtsp",
        "documentation": {}
    },
    {
        "label": "TestProtocol",
        "kind": 6,
        "importPath": "tests.unit_test.test_protocol",
        "description": "tests.unit_test.test_protocol",
        "peekOfCode": "class TestProtocol(unittest.TestCase):\n    def test_random_generation_initialization(self):\n        print(f\"Testing random generation\")\n        random_metric_tsp = GraphV1Problem(n_nodes=8)\n        self.assertEqual(random_metric_tsp.n_nodes, 8)\n        self.assertEqual(len(random_metric_tsp.nodes), 8)\n        self.assertEqual(len(random_metric_tsp.edges), 8)\n        self.assertEqual(len(random_metric_tsp.edges[0]), 8)\n    def test_fixed_coordinate_initialization(self):\n        print(f\"Testing fixed coordinate input initialization\")",
        "detail": "tests.unit_test.test_protocol",
        "documentation": {}
    },
    {
        "label": "TestRewards",
        "kind": 6,
        "importPath": "tests.unit_test.test_rewards",
        "description": "tests.unit_test.test_rewards",
        "peekOfCode": "class TestRewards(unittest.TestCase):\n    ### Suite of tests for problems that benchmark could not solve\n    def test_unsolved_all_inf(self):\n        mock_scores = [np.inf, np.inf, np.inf]\n        mock_benchmark = np.inf\n        mock_rewards = scaled_rewards(mock_scores, mock_benchmark, 'min')\n        self.assertEqual(mock_rewards, [0,0,0])\n    def test_unsolved_all_better(self):\n        mock_scores = [1, 6, 11]\n        mock_benchmark = np.inf",
        "detail": "tests.unit_test.test_rewards",
        "documentation": {}
    },
    {
        "label": "Mock",
        "kind": 6,
        "importPath": "tests.unit_test.test_scoring_mtsp",
        "description": "tests.unit_test.test_scoring_mtsp",
        "peekOfCode": "class Mock:\n    def __init__(self): \n        pass\nmock = Mock()\nload_default_dataset(mock)\nclass TestScoringFunction(unittest.TestCase):\n    def setUp(self):\n        self.graph_problem = MetricMTSPV2Generator.generate_one_sample(mock.loaded_datasets, 2000, 4)\n        self.graph_synapse = GraphV2Synapse(problem=self.graph_problem)\n        self.score_handler = ScoreResponse(self.graph_synapse)",
        "detail": "tests.unit_test.test_scoring_mtsp",
        "documentation": {}
    },
    {
        "label": "TestScoringFunction",
        "kind": 6,
        "importPath": "tests.unit_test.test_scoring_mtsp",
        "description": "tests.unit_test.test_scoring_mtsp",
        "peekOfCode": "class TestScoringFunction(unittest.TestCase):\n    def setUp(self):\n        self.graph_problem = MetricMTSPV2Generator.generate_one_sample(mock.loaded_datasets, 2000, 4)\n        self.graph_synapse = GraphV2Synapse(problem=self.graph_problem)\n        self.score_handler = ScoreResponse(self.graph_synapse)\n        self.solver = NearestNeighbourMultiSolver()\n    def test_too_few_cities(self):\n        mock_synapse = copy.deepcopy(self.graph_synapse)\n        mock_synapse.solution = [list(range(500))+[0], [0]+list(range(500,1000)) + [0], [0] + list(range(1000,1500)) + [0], [0] + list(range(1500,1999)) + [0]]\n        test_score = self.score_handler.score_response(mock_synapse)",
        "detail": "tests.unit_test.test_scoring_mtsp",
        "documentation": {}
    },
    {
        "label": "mock",
        "kind": 5,
        "importPath": "tests.unit_test.test_scoring_mtsp",
        "description": "tests.unit_test.test_scoring_mtsp",
        "peekOfCode": "mock = Mock()\nload_default_dataset(mock)\nclass TestScoringFunction(unittest.TestCase):\n    def setUp(self):\n        self.graph_problem = MetricMTSPV2Generator.generate_one_sample(mock.loaded_datasets, 2000, 4)\n        self.graph_synapse = GraphV2Synapse(problem=self.graph_problem)\n        self.score_handler = ScoreResponse(self.graph_synapse)\n        self.solver = NearestNeighbourMultiSolver()\n    def test_too_few_cities(self):\n        mock_synapse = copy.deepcopy(self.graph_synapse)",
        "detail": "tests.unit_test.test_scoring_mtsp",
        "documentation": {}
    },
    {
        "label": "TestScoringFunction",
        "kind": 6,
        "importPath": "tests.unit_test.test_scoring_tsp",
        "description": "tests.unit_test.test_scoring_tsp",
        "peekOfCode": "class TestScoringFunction(unittest.TestCase):\n    def setUp(self):\n        self.graph_problem = GraphV1Problem(n_nodes=10)\n        self.graph_synapse = GraphV1Synapse(problem=self.graph_problem)\n        self.score_handler = ScoreResponse(self.graph_synapse)\n        self.solver = NearestNeighbourSolver()\n    def test_too_few_cities(self):\n        mock_synapse = copy.deepcopy(self.graph_synapse)\n        mock_synapse.solution = [0,1,2,3,4]\n        test_score = self.score_handler.score_response(mock_synapse)",
        "detail": "tests.unit_test.test_scoring_tsp",
        "documentation": {}
    },
    {
        "label": "Mock",
        "kind": 6,
        "importPath": "tests.unit_test.test_single_depot_mtsp",
        "description": "tests.unit_test.test_single_depot_mtsp",
        "peekOfCode": "class Mock:\n    def __init__(self): \n        pass\nclass SDMTSPSolutionEnum(Enum):\n    VALID = 0\n    TOO_FEW_CITIES = 1\n    TOO_MANY_CITIES = 2\n    REPEAT_CITIES = 3\n    INVALID_DEPOT = 4\n    VISITED_DEPOT = 6",
        "detail": "tests.unit_test.test_single_depot_mtsp",
        "documentation": {}
    },
    {
        "label": "SDMTSPSolutionEnum",
        "kind": 6,
        "importPath": "tests.unit_test.test_single_depot_mtsp",
        "description": "tests.unit_test.test_single_depot_mtsp",
        "peekOfCode": "class SDMTSPSolutionEnum(Enum):\n    VALID = 0\n    TOO_FEW_CITIES = 1\n    TOO_MANY_CITIES = 2\n    REPEAT_CITIES = 3\n    INVALID_DEPOT = 4\n    VISITED_DEPOT = 6\n    DEPOT_TO_DEPOT = 7\n    NO_RETURN = 8\n    MIXED_TYPE = 9",
        "detail": "tests.unit_test.test_single_depot_mtsp",
        "documentation": {}
    },
    {
        "label": "TestScoringFunction",
        "kind": 6,
        "importPath": "tests.unit_test.test_single_depot_mtsp",
        "description": "tests.unit_test.test_single_depot_mtsp",
        "peekOfCode": "class TestScoringFunction(unittest.TestCase):\n    def setUp(self):\n        # create an md-mTSP instance\n        self.graph_problem = MetricMTSPV2Generator.generate_one_sample(mock.loaded_datasets, 2000, 4, single_depot=True)\n        self.graph_synapse = GraphV2Synapse(problem=self.graph_problem)\n        self.score_handler = ScoreResponse(self.graph_synapse)\n        self.solver = NearestNeighbourMultiSolver()\n    ### Set of tests to ensure that the scoring function is applied correctly for the multi-depot instance\n    # Did not visit all cities\n    def test_too_few_cities(self):",
        "detail": "tests.unit_test.test_single_depot_mtsp",
        "documentation": {}
    },
    {
        "label": "generate_sdmtsp_test_response",
        "kind": 2,
        "importPath": "tests.unit_test.test_single_depot_mtsp",
        "description": "tests.unit_test.test_single_depot_mtsp",
        "peekOfCode": "def generate_sdmtsp_test_response(problem:GraphV2ProblemMulti, solution_type:SDMTSPSolutionEnum):\n    assert isinstance(solution_type, SDMTSPSolutionEnum)\n    n_nodes = problem.n_nodes\n    depots = problem.depots\n    def generate_random_initial_solution(n_nodes, depots):\n        # initialize start routes\n        routes = [[x,x] for x in depots]\n        remaining_cities = list(set(range(n_nodes)).difference(depots))\n        random.shuffle(remaining_cities)\n        route_indices = cycle(range(len(depots)))",
        "detail": "tests.unit_test.test_single_depot_mtsp",
        "documentation": {}
    },
    {
        "label": "mock",
        "kind": 5,
        "importPath": "tests.unit_test.test_single_depot_mtsp",
        "description": "tests.unit_test.test_single_depot_mtsp",
        "peekOfCode": "mock = Mock()\nload_default_dataset(mock)\ndef generate_sdmtsp_test_response(problem:GraphV2ProblemMulti, solution_type:SDMTSPSolutionEnum):\n    assert isinstance(solution_type, SDMTSPSolutionEnum)\n    n_nodes = problem.n_nodes\n    depots = problem.depots\n    def generate_random_initial_solution(n_nodes, depots):\n        # initialize start routes\n        routes = [[x,x] for x in depots]\n        remaining_cities = list(set(range(n_nodes)).difference(depots))",
        "detail": "tests.unit_test.test_single_depot_mtsp",
        "documentation": {}
    },
    {
        "label": "TestSolvers",
        "kind": 6,
        "importPath": "tests.unit_test.test_solvers",
        "description": "tests.unit_test.test_solvers",
        "peekOfCode": "class TestSolvers(unittest.IsolatedAsyncioTestCase):\n    async def asyncSetUp(self):\n        self.metric_tsp = GraphV1Problem(n_nodes=10)\n        self.large_tsp = GraphV1Problem(n_nodes=100)\n        self.general_tsp = GraphV1Problem(n_nodes=10, directed=True)\n    async def test_dp_solver(self):\n        solver = DPSolver()\n        metric_solution = await solver.solve_problem(self.metric_tsp)\n        general_solution = await solver.solve_problem(self.general_tsp)\n        large_solution = await solver.solve_problem(self.large_tsp)",
        "detail": "tests.unit_test.test_solvers",
        "documentation": {}
    },
    {
        "label": "Mock",
        "kind": 6,
        "importPath": "tests.unit_test.test_validity_check",
        "description": "tests.unit_test.test_validity_check",
        "peekOfCode": "class Mock:\n    def __init__(self): \n        pass\nclass SolutionEnum(Enum):\n    VALID = 0\n    TOO_FEW_CITIES = 1\n    TOO_MANY_CITIES = 2\n    REPEAT_CITIES = 3\n    INVALID_DEPOT = 4\n    WRONG_DEPOT_ORDER = 5",
        "detail": "tests.unit_test.test_validity_check",
        "documentation": {}
    },
    {
        "label": "SolutionEnum",
        "kind": 6,
        "importPath": "tests.unit_test.test_validity_check",
        "description": "tests.unit_test.test_validity_check",
        "peekOfCode": "class SolutionEnum(Enum):\n    VALID = 0\n    TOO_FEW_CITIES = 1\n    TOO_MANY_CITIES = 2\n    REPEAT_CITIES = 3\n    INVALID_DEPOT = 4\n    WRONG_DEPOT_ORDER = 5\n    VISITED_DEPOT = 6 # visit another depot\n    DEPOT_TO_DEPOT = 7 # [0, 0] is not a valid path\n    NO_RETURN = 8",
        "detail": "tests.unit_test.test_validity_check",
        "documentation": {}
    },
    {
        "label": "generate_mdmtsp_test_response",
        "kind": 2,
        "importPath": "tests.unit_test.test_validity_check",
        "description": "tests.unit_test.test_validity_check",
        "peekOfCode": "def generate_mdmtsp_test_response(problem:GraphV2ProblemMulti, solution_type:SolutionEnum):\n    assert isinstance(solution_type, SolutionEnum)\n    n_nodes = problem.n_nodes\n    depots = problem.depots\n    def generate_random_initial_solution(n_nodes, depots):\n        # initialize start routes\n        routes = [[x,x] for x in depots]\n        remaining_cities = list(set(range(n_nodes)).difference(depots))\n        random.shuffle(remaining_cities)\n        route_indices = cycle(range(len(depots)))",
        "detail": "tests.unit_test.test_validity_check",
        "documentation": {}
    },
    {
        "label": "mock",
        "kind": 5,
        "importPath": "tests.unit_test.test_validity_check",
        "description": "tests.unit_test.test_validity_check",
        "peekOfCode": "mock = Mock()\nload_default_dataset(mock)\ndef generate_mdmtsp_test_response(problem:GraphV2ProblemMulti, solution_type:SolutionEnum):\n    assert isinstance(solution_type, SolutionEnum)\n    n_nodes = problem.n_nodes\n    depots = problem.depots\n    def generate_random_initial_solution(n_nodes, depots):\n        # initialize start routes\n        routes = [[x,x] for x in depots]\n        remaining_cities = list(set(range(n_nodes)).difference(depots))",
        "detail": "tests.unit_test.test_validity_check",
        "documentation": {}
    },
    {
        "label": "graph_problem",
        "kind": 5,
        "importPath": "tests.unit_test.test_validity_check",
        "description": "tests.unit_test.test_validity_check",
        "peekOfCode": "graph_problem = MetricMTSPV2Generator.generate_one_sample(mock.loaded_datasets, 2000, 4, single_depot=False)\ngraph_problem.depots[0] = graph_problem.depots[1]\ngraph_synapse = GraphV2Synapse(problem=graph_problem)\ngraph_synapse.solution = generate_mdmtsp_test_response(graph_problem, SolutionEnum.DEPOT_TO_DEPOT)\nprint(f\"Validity Check: {is_valid_multi_path(graph_synapse.solution,graph_synapse.problem.depots,graph_synapse.problem.n_nodes)}\")\nprint(f\"Solution Score: {get_multi_minmax_tour_distance(graph_synapse)}\")\nprint(f\"Solution Validator Check: {is_valid_solution(graph_problem, graph_synapse.solution)}\")",
        "detail": "tests.unit_test.test_validity_check",
        "documentation": {}
    },
    {
        "label": "graph_problem.depots[0]",
        "kind": 5,
        "importPath": "tests.unit_test.test_validity_check",
        "description": "tests.unit_test.test_validity_check",
        "peekOfCode": "graph_problem.depots[0] = graph_problem.depots[1]\ngraph_synapse = GraphV2Synapse(problem=graph_problem)\ngraph_synapse.solution = generate_mdmtsp_test_response(graph_problem, SolutionEnum.DEPOT_TO_DEPOT)\nprint(f\"Validity Check: {is_valid_multi_path(graph_synapse.solution,graph_synapse.problem.depots,graph_synapse.problem.n_nodes)}\")\nprint(f\"Solution Score: {get_multi_minmax_tour_distance(graph_synapse)}\")\nprint(f\"Solution Validator Check: {is_valid_solution(graph_problem, graph_synapse.solution)}\")",
        "detail": "tests.unit_test.test_validity_check",
        "documentation": {}
    },
    {
        "label": "graph_synapse",
        "kind": 5,
        "importPath": "tests.unit_test.test_validity_check",
        "description": "tests.unit_test.test_validity_check",
        "peekOfCode": "graph_synapse = GraphV2Synapse(problem=graph_problem)\ngraph_synapse.solution = generate_mdmtsp_test_response(graph_problem, SolutionEnum.DEPOT_TO_DEPOT)\nprint(f\"Validity Check: {is_valid_multi_path(graph_synapse.solution,graph_synapse.problem.depots,graph_synapse.problem.n_nodes)}\")\nprint(f\"Solution Score: {get_multi_minmax_tour_distance(graph_synapse)}\")\nprint(f\"Solution Validator Check: {is_valid_solution(graph_problem, graph_synapse.solution)}\")",
        "detail": "tests.unit_test.test_validity_check",
        "documentation": {}
    },
    {
        "label": "graph_synapse.solution",
        "kind": 5,
        "importPath": "tests.unit_test.test_validity_check",
        "description": "tests.unit_test.test_validity_check",
        "peekOfCode": "graph_synapse.solution = generate_mdmtsp_test_response(graph_problem, SolutionEnum.DEPOT_TO_DEPOT)\nprint(f\"Validity Check: {is_valid_multi_path(graph_synapse.solution,graph_synapse.problem.depots,graph_synapse.problem.n_nodes)}\")\nprint(f\"Solution Score: {get_multi_minmax_tour_distance(graph_synapse)}\")\nprint(f\"Solution Validator Check: {is_valid_solution(graph_problem, graph_synapse.solution)}\")",
        "detail": "tests.unit_test.test_validity_check",
        "documentation": {}
    },
    {
        "label": "can_show_plot",
        "kind": 2,
        "importPath": "tests.evaluate_solvers",
        "description": "tests.evaluate_solvers",
        "peekOfCode": "def can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting\n    backend = matplotlib.get_backend()\n    if backend in ['agg', 'cairo', 'svg', 'pdf', 'ps']:\n        return False",
        "detail": "tests.evaluate_solvers",
        "documentation": {}
    },
    {
        "label": "compare_problems",
        "kind": 2,
        "importPath": "tests.evaluate_solvers",
        "description": "tests.evaluate_solvers",
        "peekOfCode": "def compare_problems(solvers: List, problems: List[GraphV2Problem], loaded_datasets: dict):\n    problem_types = set([problem.problem_type for problem in problems])\n    mock_synapses = [GraphV2Synapse(problem=problem) for problem in problems]\n    # results = {solver.__class__.__name__: [] for solver in solvers}\n    run_times_dict = {solver.__class__.__name__: [] for solver in solvers}\n    scores_dict = {solver.__class__.__name__: [] for solver in solvers}\n    for i, solver in enumerate(solvers):\n        run_times = []\n        scores = []\n        print(f\"Running Solver {i+1} - {solver.__class__.__name__}\")",
        "detail": "tests.evaluate_solvers",
        "documentation": {}
    },
    {
        "label": "compute_relative_scores",
        "kind": 2,
        "importPath": "tests.evaluate_solvers",
        "description": "tests.evaluate_solvers",
        "peekOfCode": "def compute_relative_scores(scores_df: pd.DataFrame, tolerance=1e-5):\n    def normalize_row(row):\n        min_val = row.min()\n        max_val = row.max()\n        if max_val > min_val:  # To avoid division by zero\n            return (row - min_val) / (max_val - min_val)\n        else:\n            return row  # If all values are the same, return the original row\n    relative_scores = pd.DataFrame(index=scores_df.index)\n    solvers = scores_df.columns.difference(['problem_size'])",
        "detail": "tests.evaluate_solvers",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tests.evaluate_solvers",
        "description": "tests.evaluate_solvers",
        "peekOfCode": "def main():\n    if not os.path.exists(os.path.join(ROOT_DIR, SAVE_DIR)):\n        os.makedirs(os.path.join(ROOT_DIR, SAVE_DIR))\n    # create Mock object to store the dataeset\n    class Mock:\n        pass\n    mock = Mock()\n    load_default_dataset(mock) # load dataset as an attribute to mock instance\n    # Use MetricTSPGenerator to generate problems of various graph sizes\n    metric_problems, metric_sizes = MetricTSPV2Generator.generate_n_samples_without_edges(N_PROBLEMS, mock.loaded_datasets)",
        "detail": "tests.evaluate_solvers",
        "documentation": {}
    },
    {
        "label": "ROOT_DIR",
        "kind": 5,
        "importPath": "tests.evaluate_solvers",
        "description": "tests.evaluate_solvers",
        "peekOfCode": "ROOT_DIR = \"tests\"\nSAVE_DIR = \"evaluation_results\"\nN_PROBLEMS = 100\ndef can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting",
        "detail": "tests.evaluate_solvers",
        "documentation": {}
    },
    {
        "label": "SAVE_DIR",
        "kind": 5,
        "importPath": "tests.evaluate_solvers",
        "description": "tests.evaluate_solvers",
        "peekOfCode": "SAVE_DIR = \"evaluation_results\"\nN_PROBLEMS = 100\ndef can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting\n    backend = matplotlib.get_backend()",
        "detail": "tests.evaluate_solvers",
        "documentation": {}
    },
    {
        "label": "N_PROBLEMS",
        "kind": 5,
        "importPath": "tests.evaluate_solvers",
        "description": "tests.evaluate_solvers",
        "peekOfCode": "N_PROBLEMS = 100\ndef can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting\n    backend = matplotlib.get_backend()\n    if backend in ['agg', 'cairo', 'svg', 'pdf', 'ps']:",
        "detail": "tests.evaluate_solvers",
        "documentation": {}
    },
    {
        "label": "can_show_plot",
        "kind": 2,
        "importPath": "tests.evaluate_solvers_deprecated",
        "description": "tests.evaluate_solvers_deprecated",
        "peekOfCode": "def can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting\n    backend = matplotlib.get_backend()\n    if backend in ['agg', 'cairo', 'svg', 'pdf', 'ps']:\n        return False",
        "detail": "tests.evaluate_solvers_deprecated",
        "documentation": {}
    },
    {
        "label": "compare_problems",
        "kind": 2,
        "importPath": "tests.evaluate_solvers_deprecated",
        "description": "tests.evaluate_solvers_deprecated",
        "peekOfCode": "def compare_problems(solvers: List, problems: List[GraphV1Problem]):\n    problem_types = set([problem.problem_type for problem in problems])\n    mock_synapses = [GraphV1Synapse(problem=problem) for problem in problems]\n    results = {solver.__class__.__name__: [] for solver in solvers}\n    run_times_dict = {solver.__class__.__name__: [] for solver in solvers}\n    scores_dict = {solver.__class__.__name__: [] for solver in solvers}\n    for i, solver in enumerate(solvers):\n        run_times = []\n        print(f\"Running Solver {i+1} - {solver.__class__.__name__}\")\n        for mock_synapse in tqdm.tqdm(mock_synapses, desc=f\"{solver.__class__.__name__} solving {problem_types}\"):",
        "detail": "tests.evaluate_solvers_deprecated",
        "documentation": {}
    },
    {
        "label": "compute_relative_scores",
        "kind": 2,
        "importPath": "tests.evaluate_solvers_deprecated",
        "description": "tests.evaluate_solvers_deprecated",
        "peekOfCode": "def compute_relative_scores(scores_df: pd.DataFrame, tolerance=1e-5):\n    relative_scores = pd.DataFrame(index=scores_df.index)\n    solvers = scores_df.columns.difference(['problem_size'])\n    for solver in solvers:\n        relative_scores[solver] = scores_df[solvers].apply(\n            lambda row: sum(\n                np.isclose(row[solver], row[other_solver], rtol=tolerance) or row[solver] < row[other_solver]\n                for other_solver in solvers\n            ), axis=1)\n    # Normalize the relative scores to the range 0 to 1",
        "detail": "tests.evaluate_solvers_deprecated",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tests.evaluate_solvers_deprecated",
        "description": "tests.evaluate_solvers_deprecated",
        "peekOfCode": "def main():\n    if not os.path.exists(os.path.join(ROOT_DIR, SAVE_DIR)):\n        os.makedirs(os.path.join(ROOT_DIR, SAVE_DIR))\n    # Use MetricTSPGenerator to generate problems of various graph sizes\n    metric_problems, metric_sizes = MetricTSPGenerator.generate_n_samples(N_PROBLEMS)\n    test_solvers = [NearestNeighbourSolver(), BeamSearchSolver(), HPNSolver()]\n    run_times_dict, scores_dict = compare_problems(test_solvers, metric_problems)\n    # Create DataFrames for run times and scores\n    run_times_df = pd.DataFrame(run_times_dict)\n    scores_df = pd.DataFrame(scores_dict)",
        "detail": "tests.evaluate_solvers_deprecated",
        "documentation": {}
    },
    {
        "label": "ROOT_DIR",
        "kind": 5,
        "importPath": "tests.evaluate_solvers_deprecated",
        "description": "tests.evaluate_solvers_deprecated",
        "peekOfCode": "ROOT_DIR = \"tests\"\nSAVE_DIR = \"evaluation_results\"\nN_PROBLEMS = 1000\ndef can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting",
        "detail": "tests.evaluate_solvers_deprecated",
        "documentation": {}
    },
    {
        "label": "SAVE_DIR",
        "kind": 5,
        "importPath": "tests.evaluate_solvers_deprecated",
        "description": "tests.evaluate_solvers_deprecated",
        "peekOfCode": "SAVE_DIR = \"evaluation_results\"\nN_PROBLEMS = 1000\ndef can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting\n    backend = matplotlib.get_backend()",
        "detail": "tests.evaluate_solvers_deprecated",
        "documentation": {}
    },
    {
        "label": "N_PROBLEMS",
        "kind": 5,
        "importPath": "tests.evaluate_solvers_deprecated",
        "description": "tests.evaluate_solvers_deprecated",
        "peekOfCode": "N_PROBLEMS = 1000\ndef can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting\n    backend = matplotlib.get_backend()\n    if backend in ['agg', 'cairo', 'svg', 'pdf', 'ps']:",
        "detail": "tests.evaluate_solvers_deprecated",
        "documentation": {}
    },
    {
        "label": "can_show_plot",
        "kind": 2,
        "importPath": "tests.evaluate_solvers_multi",
        "description": "tests.evaluate_solvers_multi",
        "peekOfCode": "def can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting\n    backend = matplotlib.get_backend()\n    if backend in ['agg', 'cairo', 'svg', 'pdf', 'ps']:\n        return False",
        "detail": "tests.evaluate_solvers_multi",
        "documentation": {}
    },
    {
        "label": "compare_problems",
        "kind": 2,
        "importPath": "tests.evaluate_solvers_multi",
        "description": "tests.evaluate_solvers_multi",
        "peekOfCode": "def compare_problems(solvers: List, problems: List[GraphV2ProblemMulti], loaded_datasets: dict):\n    problem_types = set([problem.problem_type for problem in problems])\n    mock_synapses = [GraphV2Synapse(problem=problem) for problem in problems]\n    # results = {solver.__class__.__name__: [] for solver in solvers}\n    run_times_dict = {solver.__class__.__name__: [] for solver in solvers}\n    scores_dict = {solver.__class__.__name__: [] for solver in solvers}\n    for i, solver in enumerate(solvers):\n        run_times = []\n        scores = []\n        print(f\"Running Solver {i+1} - {solver.__class__.__name__}\")",
        "detail": "tests.evaluate_solvers_multi",
        "documentation": {}
    },
    {
        "label": "compute_relative_scores",
        "kind": 2,
        "importPath": "tests.evaluate_solvers_multi",
        "description": "tests.evaluate_solvers_multi",
        "peekOfCode": "def compute_relative_scores(scores_df: pd.DataFrame, tolerance=1e-5):\n    def normalize_row(row):\n        min_val = row.min()\n        max_val = row.max()\n        if max_val > min_val:  # To avoid division by zero\n            return (row - min_val) / (max_val - min_val)\n        else:\n            return row  # If all values are the same, return the original row\n    relative_scores = pd.DataFrame(index=scores_df.index)\n    solvers = scores_df.columns.difference(['problem_size'])",
        "detail": "tests.evaluate_solvers_multi",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tests.evaluate_solvers_multi",
        "description": "tests.evaluate_solvers_multi",
        "peekOfCode": "def main():\n    if not os.path.exists(os.path.join(ROOT_DIR, SAVE_DIR)):\n        os.makedirs(os.path.join(ROOT_DIR, SAVE_DIR))\n    # create Mock object to store the dataeset\n    class Mock:\n        pass\n    mock = Mock()\n    load_default_dataset(mock) # load dataset as an attribute to mock instance\n    # Use MetricmTSPGenerator to generate problems of various graph sizes\n    metric_mtsp_problems, metric_mtsp_sizes = MetricMTSPV2Generator.generate_n_samples_without_edges(N_PROBLEMS, mock.loaded_datasets)",
        "detail": "tests.evaluate_solvers_multi",
        "documentation": {}
    },
    {
        "label": "ROOT_DIR",
        "kind": 5,
        "importPath": "tests.evaluate_solvers_multi",
        "description": "tests.evaluate_solvers_multi",
        "peekOfCode": "ROOT_DIR = \"tests\"\nSAVE_DIR = \"evaluation_results_multi\"\nN_PROBLEMS = 100\ndef can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting",
        "detail": "tests.evaluate_solvers_multi",
        "documentation": {}
    },
    {
        "label": "SAVE_DIR",
        "kind": 5,
        "importPath": "tests.evaluate_solvers_multi",
        "description": "tests.evaluate_solvers_multi",
        "peekOfCode": "SAVE_DIR = \"evaluation_results_multi\"\nN_PROBLEMS = 100\ndef can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting\n    backend = matplotlib.get_backend()",
        "detail": "tests.evaluate_solvers_multi",
        "documentation": {}
    },
    {
        "label": "N_PROBLEMS",
        "kind": 5,
        "importPath": "tests.evaluate_solvers_multi",
        "description": "tests.evaluate_solvers_multi",
        "peekOfCode": "N_PROBLEMS = 100\ndef can_show_plot():\n    # Check if running in a headless environment\n    if os.name == 'posix':\n        display = os.getenv('DISPLAY')\n        if not display:\n            return False\n    # Check if the backend is suitable for interactive plotting\n    backend = matplotlib.get_backend()\n    if backend in ['agg', 'cairo', 'svg', 'pdf', 'ps']:",
        "detail": "tests.evaluate_solvers_multi",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "verify.generate",
        "description": "verify.generate",
        "peekOfCode": "def main(args):\n    wallet = bittensor.wallet(name=args.name)\n    keypair = wallet.coldkey\n    timestamp = datetime.now()\n    timezone = timestamp.astimezone().tzname()\n    message = f\"On {timestamp} {timezone} {args.message}\"\n    signature = keypair.sign(data=message)\n    file_contents = f\"{message}\\n\\tSigned by: {keypair.ss58_address}\\n\\tSignature: {signature.hex()}\"\n    print(file_contents)\n    open(\"message_and_signature.txt\", \"w\").write(file_contents)",
        "detail": "verify.generate",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "verify.verify",
        "description": "verify.verify",
        "peekOfCode": "def main(args):\n    file_data = open(args.file).read()\n    file_split = file_data.split(\"\\n\\t\")\n    address_line = file_split[1]\n    address_prefix = \"Signed by: \"\n    if address_line.startswith(address_prefix):\n        address = address_line[len(address_prefix) :]\n    else:\n        address = address_line\n    keypair = Keypair(ss58_address=address, ss58_format=42)",
        "detail": "verify.verify",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "data_setup",
        "description": "data_setup",
        "peekOfCode": "def main(replace_files: bool):\n    if replace_files and DATASET_DIR.exists():\n        # Remove the dataset directory and all files in it\n        shutil.rmtree(DATASET_DIR)\n        print(f\"Removed {DATASET_DIR}\")\n    # Download default datasets\n    download_default_datasets()\n    print(\"Datasets downloaded.\")\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Handle dataset downloading and management.\")",
        "detail": "data_setup",
        "documentation": {}
    },
    {
        "label": "DATASET_DIR",
        "kind": 5,
        "importPath": "data_setup",
        "description": "data_setup",
        "peekOfCode": "DATASET_DIR = Path(__file__).resolve().parent.joinpath(\"dataset\")\ndef main(replace_files: bool):\n    if replace_files and DATASET_DIR.exists():\n        # Remove the dataset directory and all files in it\n        shutil.rmtree(DATASET_DIR)\n        print(f\"Removed {DATASET_DIR}\")\n    # Download default datasets\n    download_default_datasets()\n    print(\"Datasets downloaded.\")\nif __name__ == \"__main__\":",
        "detail": "data_setup",
        "documentation": {}
    },
    {
        "label": "read_requirements",
        "kind": 2,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "def read_requirements(path):\n    with open(path, \"r\") as f:\n        requirements = f.read().splitlines()\n        processed_requirements = []\n        for req in requirements:\n            # For git or other VCS links\n            if req.startswith(\"git+\") or \"@\" in req:\n                pkg_name = re.search(r\"(#egg=)([\\w\\-_]+)\", req)\n                if pkg_name:\n                    processed_requirements.append(pkg_name.group(2))",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "requirements",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "requirements = read_requirements(\"requirements.txt\")\nhere = path.abspath(path.dirname(__file__))\nwith open(path.join(here, \"README.md\"), encoding=\"utf-8\") as f:\n    long_description = f.read()\n# loading version from setup.py\nwith codecs.open(\n    os.path.join(here, \"graphite/__init__.py\"), encoding=\"utf-8\"\n) as init_file:\n    version_match = re.search(\n        r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", init_file.read(), re.M",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "here",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "here = path.abspath(path.dirname(__file__))\nwith open(path.join(here, \"README.md\"), encoding=\"utf-8\") as f:\n    long_description = f.read()\n# loading version from setup.py\nwith codecs.open(\n    os.path.join(here, \"graphite/__init__.py\"), encoding=\"utf-8\"\n) as init_file:\n    version_match = re.search(\n        r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", init_file.read(), re.M\n    )",
        "detail": "setup",
        "documentation": {}
    }
]